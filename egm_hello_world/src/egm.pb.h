// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_egm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_egm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_egm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_egm_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_egm_2eproto;
namespace abb {
namespace egm {
class EgmCartesian;
struct EgmCartesianDefaultTypeInternal;
extern EgmCartesianDefaultTypeInternal _EgmCartesian_default_instance_;
class EgmCartesianSpeed;
struct EgmCartesianSpeedDefaultTypeInternal;
extern EgmCartesianSpeedDefaultTypeInternal _EgmCartesianSpeed_default_instance_;
class EgmClock;
struct EgmClockDefaultTypeInternal;
extern EgmClockDefaultTypeInternal _EgmClock_default_instance_;
class EgmCollisionInfo;
struct EgmCollisionInfoDefaultTypeInternal;
extern EgmCollisionInfoDefaultTypeInternal _EgmCollisionInfo_default_instance_;
class EgmEuler;
struct EgmEulerDefaultTypeInternal;
extern EgmEulerDefaultTypeInternal _EgmEuler_default_instance_;
class EgmExternalJoints;
struct EgmExternalJointsDefaultTypeInternal;
extern EgmExternalJointsDefaultTypeInternal _EgmExternalJoints_default_instance_;
class EgmFeedBack;
struct EgmFeedBackDefaultTypeInternal;
extern EgmFeedBackDefaultTypeInternal _EgmFeedBack_default_instance_;
class EgmHeader;
struct EgmHeaderDefaultTypeInternal;
extern EgmHeaderDefaultTypeInternal _EgmHeader_default_instance_;
class EgmJoints;
struct EgmJointsDefaultTypeInternal;
extern EgmJointsDefaultTypeInternal _EgmJoints_default_instance_;
class EgmMCIState;
struct EgmMCIStateDefaultTypeInternal;
extern EgmMCIStateDefaultTypeInternal _EgmMCIState_default_instance_;
class EgmMeasuredForce;
struct EgmMeasuredForceDefaultTypeInternal;
extern EgmMeasuredForceDefaultTypeInternal _EgmMeasuredForce_default_instance_;
class EgmMotorState;
struct EgmMotorStateDefaultTypeInternal;
extern EgmMotorStateDefaultTypeInternal _EgmMotorState_default_instance_;
class EgmPathCorr;
struct EgmPathCorrDefaultTypeInternal;
extern EgmPathCorrDefaultTypeInternal _EgmPathCorr_default_instance_;
class EgmPlanned;
struct EgmPlannedDefaultTypeInternal;
extern EgmPlannedDefaultTypeInternal _EgmPlanned_default_instance_;
class EgmPose;
struct EgmPoseDefaultTypeInternal;
extern EgmPoseDefaultTypeInternal _EgmPose_default_instance_;
class EgmQuaternion;
struct EgmQuaternionDefaultTypeInternal;
extern EgmQuaternionDefaultTypeInternal _EgmQuaternion_default_instance_;
class EgmRAPIDdata;
struct EgmRAPIDdataDefaultTypeInternal;
extern EgmRAPIDdataDefaultTypeInternal _EgmRAPIDdata_default_instance_;
class EgmRapidCtrlExecState;
struct EgmRapidCtrlExecStateDefaultTypeInternal;
extern EgmRapidCtrlExecStateDefaultTypeInternal _EgmRapidCtrlExecState_default_instance_;
class EgmRobot;
struct EgmRobotDefaultTypeInternal;
extern EgmRobotDefaultTypeInternal _EgmRobot_default_instance_;
class EgmSensor;
struct EgmSensorDefaultTypeInternal;
extern EgmSensorDefaultTypeInternal _EgmSensor_default_instance_;
class EgmSensorPathCorr;
struct EgmSensorPathCorrDefaultTypeInternal;
extern EgmSensorPathCorrDefaultTypeInternal _EgmSensorPathCorr_default_instance_;
class EgmSpeedRef;
struct EgmSpeedRefDefaultTypeInternal;
extern EgmSpeedRefDefaultTypeInternal _EgmSpeedRef_default_instance_;
class EgmTestSignals;
struct EgmTestSignalsDefaultTypeInternal;
extern EgmTestSignalsDefaultTypeInternal _EgmTestSignals_default_instance_;
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> ::abb::egm::EgmCartesian* Arena::CreateMaybeMessage<::abb::egm::EgmCartesian>(Arena*);
template<> ::abb::egm::EgmCartesianSpeed* Arena::CreateMaybeMessage<::abb::egm::EgmCartesianSpeed>(Arena*);
template<> ::abb::egm::EgmClock* Arena::CreateMaybeMessage<::abb::egm::EgmClock>(Arena*);
template<> ::abb::egm::EgmCollisionInfo* Arena::CreateMaybeMessage<::abb::egm::EgmCollisionInfo>(Arena*);
template<> ::abb::egm::EgmEuler* Arena::CreateMaybeMessage<::abb::egm::EgmEuler>(Arena*);
template<> ::abb::egm::EgmExternalJoints* Arena::CreateMaybeMessage<::abb::egm::EgmExternalJoints>(Arena*);
template<> ::abb::egm::EgmFeedBack* Arena::CreateMaybeMessage<::abb::egm::EgmFeedBack>(Arena*);
template<> ::abb::egm::EgmHeader* Arena::CreateMaybeMessage<::abb::egm::EgmHeader>(Arena*);
template<> ::abb::egm::EgmJoints* Arena::CreateMaybeMessage<::abb::egm::EgmJoints>(Arena*);
template<> ::abb::egm::EgmMCIState* Arena::CreateMaybeMessage<::abb::egm::EgmMCIState>(Arena*);
template<> ::abb::egm::EgmMeasuredForce* Arena::CreateMaybeMessage<::abb::egm::EgmMeasuredForce>(Arena*);
template<> ::abb::egm::EgmMotorState* Arena::CreateMaybeMessage<::abb::egm::EgmMotorState>(Arena*);
template<> ::abb::egm::EgmPathCorr* Arena::CreateMaybeMessage<::abb::egm::EgmPathCorr>(Arena*);
template<> ::abb::egm::EgmPlanned* Arena::CreateMaybeMessage<::abb::egm::EgmPlanned>(Arena*);
template<> ::abb::egm::EgmPose* Arena::CreateMaybeMessage<::abb::egm::EgmPose>(Arena*);
template<> ::abb::egm::EgmQuaternion* Arena::CreateMaybeMessage<::abb::egm::EgmQuaternion>(Arena*);
template<> ::abb::egm::EgmRAPIDdata* Arena::CreateMaybeMessage<::abb::egm::EgmRAPIDdata>(Arena*);
template<> ::abb::egm::EgmRapidCtrlExecState* Arena::CreateMaybeMessage<::abb::egm::EgmRapidCtrlExecState>(Arena*);
template<> ::abb::egm::EgmRobot* Arena::CreateMaybeMessage<::abb::egm::EgmRobot>(Arena*);
template<> ::abb::egm::EgmSensor* Arena::CreateMaybeMessage<::abb::egm::EgmSensor>(Arena*);
template<> ::abb::egm::EgmSensorPathCorr* Arena::CreateMaybeMessage<::abb::egm::EgmSensorPathCorr>(Arena*);
template<> ::abb::egm::EgmSpeedRef* Arena::CreateMaybeMessage<::abb::egm::EgmSpeedRef>(Arena*);
template<> ::abb::egm::EgmTestSignals* Arena::CreateMaybeMessage<::abb::egm::EgmTestSignals>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abb {
namespace egm {

enum EgmHeader_MessageType : int {
  EgmHeader_MessageType_MSGTYPE_UNDEFINED = 0,
  EgmHeader_MessageType_MSGTYPE_COMMAND = 1,
  EgmHeader_MessageType_MSGTYPE_DATA = 2,
  EgmHeader_MessageType_MSGTYPE_CORRECTION = 3,
  EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION = 4
};
bool EgmHeader_MessageType_IsValid(int value);
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MIN = EgmHeader_MessageType_MSGTYPE_UNDEFINED;
constexpr EgmHeader_MessageType EgmHeader_MessageType_MessageType_MAX = EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
constexpr int EgmHeader_MessageType_MessageType_ARRAYSIZE = EgmHeader_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmHeader_MessageType_descriptor();
template<typename T>
inline const std::string& EgmHeader_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmHeader_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmHeader_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmHeader_MessageType_descriptor(), enum_t_value);
}
inline bool EgmHeader_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmHeader_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmHeader_MessageType>(
    EgmHeader_MessageType_descriptor(), name, value);
}
enum EgmMotorState_MotorStateType : int {
  EgmMotorState_MotorStateType_MOTORS_UNDEFINED = 0,
  EgmMotorState_MotorStateType_MOTORS_ON = 1,
  EgmMotorState_MotorStateType_MOTORS_OFF = 2
};
bool EgmMotorState_MotorStateType_IsValid(int value);
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MIN = EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
constexpr EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MAX = EgmMotorState_MotorStateType_MOTORS_OFF;
constexpr int EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE = EgmMotorState_MotorStateType_MotorStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMotorState_MotorStateType_descriptor();
template<typename T>
inline const std::string& EgmMotorState_MotorStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmMotorState_MotorStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmMotorState_MotorStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmMotorState_MotorStateType_descriptor(), enum_t_value);
}
inline bool EgmMotorState_MotorStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmMotorState_MotorStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmMotorState_MotorStateType>(
    EgmMotorState_MotorStateType_descriptor(), name, value);
}
enum EgmMCIState_MCIStateType : int {
  EgmMCIState_MCIStateType_MCI_UNDEFINED = 0,
  EgmMCIState_MCIStateType_MCI_ERROR = 1,
  EgmMCIState_MCIStateType_MCI_STOPPED = 2,
  EgmMCIState_MCIStateType_MCI_RUNNING = 3
};
bool EgmMCIState_MCIStateType_IsValid(int value);
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MIN = EgmMCIState_MCIStateType_MCI_UNDEFINED;
constexpr EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MAX = EgmMCIState_MCIStateType_MCI_RUNNING;
constexpr int EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE = EgmMCIState_MCIStateType_MCIStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMCIState_MCIStateType_descriptor();
template<typename T>
inline const std::string& EgmMCIState_MCIStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmMCIState_MCIStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmMCIState_MCIStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmMCIState_MCIStateType_descriptor(), enum_t_value);
}
inline bool EgmMCIState_MCIStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmMCIState_MCIStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmMCIState_MCIStateType>(
    EgmMCIState_MCIStateType_descriptor(), name, value);
}
enum EgmRapidCtrlExecState_RapidCtrlExecStateType : int {
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED = 0,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED = 1,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING = 2
};
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value);
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
constexpr int EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
template<typename T>
inline const std::string& EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgmRapidCtrlExecState_RapidCtrlExecStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgmRapidCtrlExecState_RapidCtrlExecStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), enum_t_value);
}
inline bool EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgmRapidCtrlExecState_RapidCtrlExecStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgmRapidCtrlExecState_RapidCtrlExecStateType>(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), name, value);
}
// ===================================================================

class EgmHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmHeader) */ {
 public:
  inline EgmHeader() : EgmHeader(nullptr) {}
  ~EgmHeader() override;
  explicit PROTOBUF_CONSTEXPR EgmHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmHeader(const EgmHeader& from);
  EgmHeader(EgmHeader&& from) noexcept
    : EgmHeader() {
    *this = ::std::move(from);
  }

  inline EgmHeader& operator=(const EgmHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmHeader& operator=(EgmHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmHeader* internal_default_instance() {
    return reinterpret_cast<const EgmHeader*>(
               &_EgmHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EgmHeader& a, EgmHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmHeader& from) {
    EgmHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmHeader";
  }
  protected:
  explicit EgmHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EgmHeader_MessageType MessageType;
  static constexpr MessageType MSGTYPE_UNDEFINED =
    EgmHeader_MessageType_MSGTYPE_UNDEFINED;
  static constexpr MessageType MSGTYPE_COMMAND =
    EgmHeader_MessageType_MSGTYPE_COMMAND;
  static constexpr MessageType MSGTYPE_DATA =
    EgmHeader_MessageType_MSGTYPE_DATA;
  static constexpr MessageType MSGTYPE_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_CORRECTION;
  static constexpr MessageType MSGTYPE_PATH_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
  static inline bool MessageType_IsValid(int value) {
    return EgmHeader_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    EgmHeader_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    EgmHeader_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    EgmHeader_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return EgmHeader_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return EgmHeader_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return EgmHeader_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeqnoFieldNumber = 1,
    kTmFieldNumber = 2,
    kMtypeFieldNumber = 3,
  };
  // optional uint32 seqno = 1;
  bool has_seqno() const;
  private:
  bool _internal_has_seqno() const;
  public:
  void clear_seqno();
  uint32_t seqno() const;
  void set_seqno(uint32_t value);
  private:
  uint32_t _internal_seqno() const;
  void _internal_set_seqno(uint32_t value);
  public:

  // optional uint32 tm = 2;
  bool has_tm() const;
  private:
  bool _internal_has_tm() const;
  public:
  void clear_tm();
  uint32_t tm() const;
  void set_tm(uint32_t value);
  private:
  uint32_t _internal_tm() const;
  void _internal_set_tm(uint32_t value);
  public:

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  bool has_mtype() const;
  private:
  bool _internal_has_mtype() const;
  public:
  void clear_mtype();
  ::abb::egm::EgmHeader_MessageType mtype() const;
  void set_mtype(::abb::egm::EgmHeader_MessageType value);
  private:
  ::abb::egm::EgmHeader_MessageType _internal_mtype() const;
  void _internal_set_mtype(::abb::egm::EgmHeader_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t seqno_;
    uint32_t tm_;
    int mtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmCartesian final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesian) */ {
 public:
  inline EgmCartesian() : EgmCartesian(nullptr) {}
  ~EgmCartesian() override;
  explicit PROTOBUF_CONSTEXPR EgmCartesian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmCartesian(const EgmCartesian& from);
  EgmCartesian(EgmCartesian&& from) noexcept
    : EgmCartesian() {
    *this = ::std::move(from);
  }

  inline EgmCartesian& operator=(const EgmCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesian& operator=(EgmCartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmCartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmCartesian* internal_default_instance() {
    return reinterpret_cast<const EgmCartesian*>(
               &_EgmCartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EgmCartesian& a, EgmCartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmCartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmCartesian>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmCartesian& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmCartesian& from) {
    EgmCartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmCartesian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmCartesian";
  }
  protected:
  explicit EgmCartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesian)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmQuaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmQuaternion) */ {
 public:
  inline EgmQuaternion() : EgmQuaternion(nullptr) {}
  ~EgmQuaternion() override;
  explicit PROTOBUF_CONSTEXPR EgmQuaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmQuaternion(const EgmQuaternion& from);
  EgmQuaternion(EgmQuaternion&& from) noexcept
    : EgmQuaternion() {
    *this = ::std::move(from);
  }

  inline EgmQuaternion& operator=(const EgmQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmQuaternion& operator=(EgmQuaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmQuaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmQuaternion* internal_default_instance() {
    return reinterpret_cast<const EgmQuaternion*>(
               &_EgmQuaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EgmQuaternion& a, EgmQuaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmQuaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmQuaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmQuaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmQuaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmQuaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmQuaternion& from) {
    EgmQuaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmQuaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmQuaternion";
  }
  protected:
  explicit EgmQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU0FieldNumber = 1,
    kU1FieldNumber = 2,
    kU2FieldNumber = 3,
    kU3FieldNumber = 4,
  };
  // required double u0 = 1;
  bool has_u0() const;
  private:
  bool _internal_has_u0() const;
  public:
  void clear_u0();
  double u0() const;
  void set_u0(double value);
  private:
  double _internal_u0() const;
  void _internal_set_u0(double value);
  public:

  // required double u1 = 2;
  bool has_u1() const;
  private:
  bool _internal_has_u1() const;
  public:
  void clear_u1();
  double u1() const;
  void set_u1(double value);
  private:
  double _internal_u1() const;
  void _internal_set_u1(double value);
  public:

  // required double u2 = 3;
  bool has_u2() const;
  private:
  bool _internal_has_u2() const;
  public:
  void clear_u2();
  double u2() const;
  void set_u2(double value);
  private:
  double _internal_u2() const;
  void _internal_set_u2(double value);
  public:

  // required double u3 = 4;
  bool has_u3() const;
  private:
  bool _internal_has_u3() const;
  public:
  void clear_u3();
  double u3() const;
  void set_u3(double value);
  private:
  double _internal_u3() const;
  void _internal_set_u3(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmQuaternion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double u0_;
    double u1_;
    double u2_;
    double u3_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmEuler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmEuler) */ {
 public:
  inline EgmEuler() : EgmEuler(nullptr) {}
  ~EgmEuler() override;
  explicit PROTOBUF_CONSTEXPR EgmEuler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmEuler(const EgmEuler& from);
  EgmEuler(EgmEuler&& from) noexcept
    : EgmEuler() {
    *this = ::std::move(from);
  }

  inline EgmEuler& operator=(const EgmEuler& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmEuler& operator=(EgmEuler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmEuler& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmEuler* internal_default_instance() {
    return reinterpret_cast<const EgmEuler*>(
               &_EgmEuler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EgmEuler& a, EgmEuler& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmEuler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmEuler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmEuler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmEuler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmEuler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmEuler& from) {
    EgmEuler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmEuler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmEuler";
  }
  protected:
  explicit EgmEuler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // required double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // required double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmEuler)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmClock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmClock) */ {
 public:
  inline EgmClock() : EgmClock(nullptr) {}
  ~EgmClock() override;
  explicit PROTOBUF_CONSTEXPR EgmClock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmClock(const EgmClock& from);
  EgmClock(EgmClock&& from) noexcept
    : EgmClock() {
    *this = ::std::move(from);
  }

  inline EgmClock& operator=(const EgmClock& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmClock& operator=(EgmClock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmClock& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmClock* internal_default_instance() {
    return reinterpret_cast<const EgmClock*>(
               &_EgmClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EgmClock& a, EgmClock& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmClock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmClock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmClock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmClock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmClock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmClock& from) {
    EgmClock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmClock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmClock";
  }
  protected:
  explicit EgmClock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecFieldNumber = 1,
    kUsecFieldNumber = 2,
  };
  // required uint64 sec = 1;
  bool has_sec() const;
  private:
  bool _internal_has_sec() const;
  public:
  void clear_sec();
  uint64_t sec() const;
  void set_sec(uint64_t value);
  private:
  uint64_t _internal_sec() const;
  void _internal_set_sec(uint64_t value);
  public:

  // required uint64 usec = 2;
  bool has_usec() const;
  private:
  bool _internal_has_usec() const;
  public:
  void clear_usec();
  uint64_t usec() const;
  void set_usec(uint64_t value);
  private:
  uint64_t _internal_usec() const;
  void _internal_set_usec(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmClock)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t sec_;
    uint64_t usec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPose) */ {
 public:
  inline EgmPose() : EgmPose(nullptr) {}
  ~EgmPose() override;
  explicit PROTOBUF_CONSTEXPR EgmPose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmPose(const EgmPose& from);
  EgmPose(EgmPose&& from) noexcept
    : EgmPose() {
    *this = ::std::move(from);
  }

  inline EgmPose& operator=(const EgmPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPose& operator=(EgmPose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPose& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPose* internal_default_instance() {
    return reinterpret_cast<const EgmPose*>(
               &_EgmPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EgmPose& a, EgmPose& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmPose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmPose& from) {
    EgmPose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPose";
  }
  protected:
  explicit EgmPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kOrientFieldNumber = 2,
    kEulerFieldNumber = 3,
  };
  // optional .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::abb::egm::EgmCartesian& pos() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);
  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::abb::egm::EgmCartesian* pos);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  // optional .abb.egm.EgmQuaternion orient = 2;
  bool has_orient() const;
  private:
  bool _internal_has_orient() const;
  public:
  void clear_orient();
  const ::abb::egm::EgmQuaternion& orient() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmQuaternion* release_orient();
  ::abb::egm::EgmQuaternion* mutable_orient();
  void set_allocated_orient(::abb::egm::EgmQuaternion* orient);
  private:
  const ::abb::egm::EgmQuaternion& _internal_orient() const;
  ::abb::egm::EgmQuaternion* _internal_mutable_orient();
  public:
  void unsafe_arena_set_allocated_orient(
      ::abb::egm::EgmQuaternion* orient);
  ::abb::egm::EgmQuaternion* unsafe_arena_release_orient();

  // optional .abb.egm.EgmEuler euler = 3;
  bool has_euler() const;
  private:
  bool _internal_has_euler() const;
  public:
  void clear_euler();
  const ::abb::egm::EgmEuler& euler() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmEuler* release_euler();
  ::abb::egm::EgmEuler* mutable_euler();
  void set_allocated_euler(::abb::egm::EgmEuler* euler);
  private:
  const ::abb::egm::EgmEuler& _internal_euler() const;
  ::abb::egm::EgmEuler* _internal_mutable_euler();
  public:
  void unsafe_arena_set_allocated_euler(
      ::abb::egm::EgmEuler* euler);
  ::abb::egm::EgmEuler* unsafe_arena_release_euler();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmCartesian* pos_;
    ::abb::egm::EgmQuaternion* orient_;
    ::abb::egm::EgmEuler* euler_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmCartesianSpeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesianSpeed) */ {
 public:
  inline EgmCartesianSpeed() : EgmCartesianSpeed(nullptr) {}
  ~EgmCartesianSpeed() override;
  explicit PROTOBUF_CONSTEXPR EgmCartesianSpeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmCartesianSpeed(const EgmCartesianSpeed& from);
  EgmCartesianSpeed(EgmCartesianSpeed&& from) noexcept
    : EgmCartesianSpeed() {
    *this = ::std::move(from);
  }

  inline EgmCartesianSpeed& operator=(const EgmCartesianSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCartesianSpeed& operator=(EgmCartesianSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmCartesianSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmCartesianSpeed* internal_default_instance() {
    return reinterpret_cast<const EgmCartesianSpeed*>(
               &_EgmCartesianSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EgmCartesianSpeed& a, EgmCartesianSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCartesianSpeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCartesianSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmCartesianSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmCartesianSpeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmCartesianSpeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmCartesianSpeed& from) {
    EgmCartesianSpeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmCartesianSpeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmCartesianSpeed";
  }
  protected:
  explicit EgmCartesianSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated double value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  double _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_value() const;
  void _internal_add_value(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_value();
  public:
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesianSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmJoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmJoints) */ {
 public:
  inline EgmJoints() : EgmJoints(nullptr) {}
  ~EgmJoints() override;
  explicit PROTOBUF_CONSTEXPR EgmJoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmJoints(const EgmJoints& from);
  EgmJoints(EgmJoints&& from) noexcept
    : EgmJoints() {
    *this = ::std::move(from);
  }

  inline EgmJoints& operator=(const EgmJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmJoints& operator=(EgmJoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmJoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmJoints* internal_default_instance() {
    return reinterpret_cast<const EgmJoints*>(
               &_EgmJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EgmJoints& a, EgmJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmJoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmJoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmJoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmJoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmJoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmJoints& from) {
    EgmJoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmJoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmJoints";
  }
  protected:
  explicit EgmJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  private:
  double _internal_joints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joints() const;
  void _internal_add_joints(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joints();
  public:
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmJoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmExternalJoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmExternalJoints) */ {
 public:
  inline EgmExternalJoints() : EgmExternalJoints(nullptr) {}
  ~EgmExternalJoints() override;
  explicit PROTOBUF_CONSTEXPR EgmExternalJoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmExternalJoints(const EgmExternalJoints& from);
  EgmExternalJoints(EgmExternalJoints&& from) noexcept
    : EgmExternalJoints() {
    *this = ::std::move(from);
  }

  inline EgmExternalJoints& operator=(const EgmExternalJoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmExternalJoints& operator=(EgmExternalJoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmExternalJoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmExternalJoints* internal_default_instance() {
    return reinterpret_cast<const EgmExternalJoints*>(
               &_EgmExternalJoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EgmExternalJoints& a, EgmExternalJoints& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmExternalJoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmExternalJoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmExternalJoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmExternalJoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmExternalJoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmExternalJoints& from) {
    EgmExternalJoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmExternalJoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmExternalJoints";
  }
  protected:
  explicit EgmExternalJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
  };
  // repeated double joints = 1;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  private:
  double _internal_joints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_joints() const;
  void _internal_add_joints(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_joints();
  public:
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      joints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmExternalJoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > joints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPlanned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPlanned) */ {
 public:
  inline EgmPlanned() : EgmPlanned(nullptr) {}
  ~EgmPlanned() override;
  explicit PROTOBUF_CONSTEXPR EgmPlanned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmPlanned(const EgmPlanned& from);
  EgmPlanned(EgmPlanned&& from) noexcept
    : EgmPlanned() {
    *this = ::std::move(from);
  }

  inline EgmPlanned& operator=(const EgmPlanned& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPlanned& operator=(EgmPlanned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPlanned& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPlanned* internal_default_instance() {
    return reinterpret_cast<const EgmPlanned*>(
               &_EgmPlanned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EgmPlanned& a, EgmPlanned& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPlanned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPlanned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPlanned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPlanned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmPlanned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmPlanned& from) {
    EgmPlanned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPlanned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPlanned";
  }
  protected:
  explicit EgmPlanned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::EgmPose& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);
  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::EgmPose* cartesian);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::EgmClock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* time);
  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::EgmClock* time);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPlanned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmPose* cartesian_;
    ::abb::egm::EgmJoints* externaljoints_;
    ::abb::egm::EgmClock* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSpeedRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSpeedRef) */ {
 public:
  inline EgmSpeedRef() : EgmSpeedRef(nullptr) {}
  ~EgmSpeedRef() override;
  explicit PROTOBUF_CONSTEXPR EgmSpeedRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmSpeedRef(const EgmSpeedRef& from);
  EgmSpeedRef(EgmSpeedRef&& from) noexcept
    : EgmSpeedRef() {
    *this = ::std::move(from);
  }

  inline EgmSpeedRef& operator=(const EgmSpeedRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSpeedRef& operator=(EgmSpeedRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSpeedRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSpeedRef* internal_default_instance() {
    return reinterpret_cast<const EgmSpeedRef*>(
               &_EgmSpeedRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EgmSpeedRef& a, EgmSpeedRef& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSpeedRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSpeedRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSpeedRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSpeedRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmSpeedRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmSpeedRef& from) {
    EgmSpeedRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSpeedRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSpeedRef";
  }
  protected:
  explicit EgmSpeedRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesiansFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  bool has_cartesians() const;
  private:
  bool _internal_has_cartesians() const;
  public:
  void clear_cartesians();
  const ::abb::egm::EgmCartesianSpeed& cartesians() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesianSpeed* release_cartesians();
  ::abb::egm::EgmCartesianSpeed* mutable_cartesians();
  void set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians);
  private:
  const ::abb::egm::EgmCartesianSpeed& _internal_cartesians() const;
  ::abb::egm::EgmCartesianSpeed* _internal_mutable_cartesians();
  public:
  void unsafe_arena_set_allocated_cartesians(
      ::abb::egm::EgmCartesianSpeed* cartesians);
  ::abb::egm::EgmCartesianSpeed* unsafe_arena_release_cartesians();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSpeedRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmCartesianSpeed* cartesians_;
    ::abb::egm::EgmJoints* externaljoints_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmPathCorr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPathCorr) */ {
 public:
  inline EgmPathCorr() : EgmPathCorr(nullptr) {}
  ~EgmPathCorr() override;
  explicit PROTOBUF_CONSTEXPR EgmPathCorr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmPathCorr(const EgmPathCorr& from);
  EgmPathCorr(EgmPathCorr&& from) noexcept
    : EgmPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmPathCorr& operator=(const EgmPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmPathCorr& operator=(EgmPathCorr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmPathCorr& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmPathCorr*>(
               &_EgmPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EgmPathCorr& a, EgmPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmPathCorr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmPathCorr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmPathCorr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmPathCorr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmPathCorr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmPathCorr& from) {
    EgmPathCorr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmPathCorr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmPathCorr";
  }
  protected:
  explicit EgmPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kAgeFieldNumber = 2,
  };
  // required .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::abb::egm::EgmCartesian& pos() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCartesian* release_pos();
  ::abb::egm::EgmCartesian* mutable_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);
  private:
  const ::abb::egm::EgmCartesian& _internal_pos() const;
  ::abb::egm::EgmCartesian* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::abb::egm::EgmCartesian* pos);
  ::abb::egm::EgmCartesian* unsafe_arena_release_pos();

  // required uint32 age = 2;
  bool has_age() const;
  private:
  bool _internal_has_age() const;
  public:
  void clear_age();
  uint32_t age() const;
  void set_age(uint32_t value);
  private:
  uint32_t _internal_age() const;
  void _internal_set_age(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPathCorr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmCartesian* pos_;
    uint32_t age_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmFeedBack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmFeedBack) */ {
 public:
  inline EgmFeedBack() : EgmFeedBack(nullptr) {}
  ~EgmFeedBack() override;
  explicit PROTOBUF_CONSTEXPR EgmFeedBack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmFeedBack(const EgmFeedBack& from);
  EgmFeedBack(EgmFeedBack&& from) noexcept
    : EgmFeedBack() {
    *this = ::std::move(from);
  }

  inline EgmFeedBack& operator=(const EgmFeedBack& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmFeedBack& operator=(EgmFeedBack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmFeedBack& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmFeedBack* internal_default_instance() {
    return reinterpret_cast<const EgmFeedBack*>(
               &_EgmFeedBack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EgmFeedBack& a, EgmFeedBack& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmFeedBack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmFeedBack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmFeedBack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmFeedBack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmFeedBack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmFeedBack& from) {
    EgmFeedBack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmFeedBack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmFeedBack";
  }
  protected:
  explicit EgmFeedBack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 1,
    kCartesianFieldNumber = 2,
    kExternalJointsFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  private:
  bool _internal_has_joints() const;
  public:
  void clear_joints();
  const ::abb::egm::EgmJoints& joints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_joints();
  ::abb::egm::EgmJoints* mutable_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);
  private:
  const ::abb::egm::EgmJoints& _internal_joints() const;
  ::abb::egm::EgmJoints* _internal_mutable_joints();
  public:
  void unsafe_arena_set_allocated_joints(
      ::abb::egm::EgmJoints* joints);
  ::abb::egm::EgmJoints* unsafe_arena_release_joints();

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  private:
  bool _internal_has_cartesian() const;
  public:
  void clear_cartesian();
  const ::abb::egm::EgmPose& cartesian() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPose* release_cartesian();
  ::abb::egm::EgmPose* mutable_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);
  private:
  const ::abb::egm::EgmPose& _internal_cartesian() const;
  ::abb::egm::EgmPose* _internal_mutable_cartesian();
  public:
  void unsafe_arena_set_allocated_cartesian(
      ::abb::egm::EgmPose* cartesian);
  ::abb::egm::EgmPose* unsafe_arena_release_cartesian();

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  private:
  bool _internal_has_externaljoints() const;
  public:
  void clear_externaljoints();
  const ::abb::egm::EgmJoints& externaljoints() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmJoints* release_externaljoints();
  ::abb::egm::EgmJoints* mutable_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);
  private:
  const ::abb::egm::EgmJoints& _internal_externaljoints() const;
  ::abb::egm::EgmJoints* _internal_mutable_externaljoints();
  public:
  void unsafe_arena_set_allocated_externaljoints(
      ::abb::egm::EgmJoints* externaljoints);
  ::abb::egm::EgmJoints* unsafe_arena_release_externaljoints();

  // optional .abb.egm.EgmClock time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::abb::egm::EgmClock& time() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmClock* release_time();
  ::abb::egm::EgmClock* mutable_time();
  void set_allocated_time(::abb::egm::EgmClock* time);
  private:
  const ::abb::egm::EgmClock& _internal_time() const;
  ::abb::egm::EgmClock* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::abb::egm::EgmClock* time);
  ::abb::egm::EgmClock* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmFeedBack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmJoints* joints_;
    ::abb::egm::EgmPose* cartesian_;
    ::abb::egm::EgmJoints* externaljoints_;
    ::abb::egm::EgmClock* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMotorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMotorState) */ {
 public:
  inline EgmMotorState() : EgmMotorState(nullptr) {}
  ~EgmMotorState() override;
  explicit PROTOBUF_CONSTEXPR EgmMotorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmMotorState(const EgmMotorState& from);
  EgmMotorState(EgmMotorState&& from) noexcept
    : EgmMotorState() {
    *this = ::std::move(from);
  }

  inline EgmMotorState& operator=(const EgmMotorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMotorState& operator=(EgmMotorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMotorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMotorState* internal_default_instance() {
    return reinterpret_cast<const EgmMotorState*>(
               &_EgmMotorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EgmMotorState& a, EgmMotorState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMotorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMotorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMotorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMotorState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmMotorState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmMotorState& from) {
    EgmMotorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMotorState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMotorState";
  }
  protected:
  explicit EgmMotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EgmMotorState_MotorStateType MotorStateType;
  static constexpr MotorStateType MOTORS_UNDEFINED =
    EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
  static constexpr MotorStateType MOTORS_ON =
    EgmMotorState_MotorStateType_MOTORS_ON;
  static constexpr MotorStateType MOTORS_OFF =
    EgmMotorState_MotorStateType_MOTORS_OFF;
  static inline bool MotorStateType_IsValid(int value) {
    return EgmMotorState_MotorStateType_IsValid(value);
  }
  static constexpr MotorStateType MotorStateType_MIN =
    EgmMotorState_MotorStateType_MotorStateType_MIN;
  static constexpr MotorStateType MotorStateType_MAX =
    EgmMotorState_MotorStateType_MotorStateType_MAX;
  static constexpr int MotorStateType_ARRAYSIZE =
    EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorStateType_descriptor() {
    return EgmMotorState_MotorStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorStateType_Name.");
    return EgmMotorState_MotorStateType_Name(enum_t_value);
  }
  static inline bool MotorStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorStateType* value) {
    return EgmMotorState_MotorStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmMotorState_MotorStateType state() const;
  void set_state(::abb::egm::EgmMotorState_MotorStateType value);
  private:
  ::abb::egm::EgmMotorState_MotorStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMotorState_MotorStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMotorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMCIState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMCIState) */ {
 public:
  inline EgmMCIState() : EgmMCIState(nullptr) {}
  ~EgmMCIState() override;
  explicit PROTOBUF_CONSTEXPR EgmMCIState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmMCIState(const EgmMCIState& from);
  EgmMCIState(EgmMCIState&& from) noexcept
    : EgmMCIState() {
    *this = ::std::move(from);
  }

  inline EgmMCIState& operator=(const EgmMCIState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMCIState& operator=(EgmMCIState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMCIState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMCIState* internal_default_instance() {
    return reinterpret_cast<const EgmMCIState*>(
               &_EgmMCIState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EgmMCIState& a, EgmMCIState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMCIState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMCIState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMCIState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMCIState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmMCIState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmMCIState& from) {
    EgmMCIState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMCIState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMCIState";
  }
  protected:
  explicit EgmMCIState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EgmMCIState_MCIStateType MCIStateType;
  static constexpr MCIStateType MCI_UNDEFINED =
    EgmMCIState_MCIStateType_MCI_UNDEFINED;
  static constexpr MCIStateType MCI_ERROR =
    EgmMCIState_MCIStateType_MCI_ERROR;
  static constexpr MCIStateType MCI_STOPPED =
    EgmMCIState_MCIStateType_MCI_STOPPED;
  static constexpr MCIStateType MCI_RUNNING =
    EgmMCIState_MCIStateType_MCI_RUNNING;
  static inline bool MCIStateType_IsValid(int value) {
    return EgmMCIState_MCIStateType_IsValid(value);
  }
  static constexpr MCIStateType MCIStateType_MIN =
    EgmMCIState_MCIStateType_MCIStateType_MIN;
  static constexpr MCIStateType MCIStateType_MAX =
    EgmMCIState_MCIStateType_MCIStateType_MAX;
  static constexpr int MCIStateType_ARRAYSIZE =
    EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MCIStateType_descriptor() {
    return EgmMCIState_MCIStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& MCIStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MCIStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MCIStateType_Name.");
    return EgmMCIState_MCIStateType_Name(enum_t_value);
  }
  static inline bool MCIStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MCIStateType* value) {
    return EgmMCIState_MCIStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmMCIState_MCIStateType state() const;
  void set_state(::abb::egm::EgmMCIState_MCIStateType value);
  private:
  ::abb::egm::EgmMCIState_MCIStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmMCIState_MCIStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMCIState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmRapidCtrlExecState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRapidCtrlExecState) */ {
 public:
  inline EgmRapidCtrlExecState() : EgmRapidCtrlExecState(nullptr) {}
  ~EgmRapidCtrlExecState() override;
  explicit PROTOBUF_CONSTEXPR EgmRapidCtrlExecState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from);
  EgmRapidCtrlExecState(EgmRapidCtrlExecState&& from) noexcept
    : EgmRapidCtrlExecState() {
    *this = ::std::move(from);
  }

  inline EgmRapidCtrlExecState& operator=(const EgmRapidCtrlExecState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRapidCtrlExecState& operator=(EgmRapidCtrlExecState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmRapidCtrlExecState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmRapidCtrlExecState* internal_default_instance() {
    return reinterpret_cast<const EgmRapidCtrlExecState*>(
               &_EgmRapidCtrlExecState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EgmRapidCtrlExecState& a, EgmRapidCtrlExecState& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRapidCtrlExecState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmRapidCtrlExecState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmRapidCtrlExecState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmRapidCtrlExecState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmRapidCtrlExecState& from) {
    EgmRapidCtrlExecState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmRapidCtrlExecState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmRapidCtrlExecState";
  }
  protected:
  explicit EgmRapidCtrlExecState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EgmRapidCtrlExecState_RapidCtrlExecStateType RapidCtrlExecStateType;
  static constexpr RapidCtrlExecStateType RAPID_UNDEFINED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
  static constexpr RapidCtrlExecStateType RAPID_STOPPED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED;
  static constexpr RapidCtrlExecStateType RAPID_RUNNING =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
  static inline bool RapidCtrlExecStateType_IsValid(int value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value);
  }
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MIN =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN;
  static constexpr RapidCtrlExecStateType RapidCtrlExecStateType_MAX =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX;
  static constexpr int RapidCtrlExecStateType_ARRAYSIZE =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RapidCtrlExecStateType_descriptor() {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& RapidCtrlExecStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RapidCtrlExecStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RapidCtrlExecStateType_Name.");
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(enum_t_value);
  }
  static inline bool RapidCtrlExecStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RapidCtrlExecStateType* value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType state() const;
  void set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);
  private:
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType _internal_state() const;
  void _internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRapidCtrlExecState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmTestSignals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmTestSignals) */ {
 public:
  inline EgmTestSignals() : EgmTestSignals(nullptr) {}
  ~EgmTestSignals() override;
  explicit PROTOBUF_CONSTEXPR EgmTestSignals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmTestSignals(const EgmTestSignals& from);
  EgmTestSignals(EgmTestSignals&& from) noexcept
    : EgmTestSignals() {
    *this = ::std::move(from);
  }

  inline EgmTestSignals& operator=(const EgmTestSignals& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmTestSignals& operator=(EgmTestSignals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmTestSignals& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmTestSignals* internal_default_instance() {
    return reinterpret_cast<const EgmTestSignals*>(
               &_EgmTestSignals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EgmTestSignals& a, EgmTestSignals& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmTestSignals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmTestSignals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmTestSignals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmTestSignals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmTestSignals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmTestSignals& from) {
    EgmTestSignals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmTestSignals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmTestSignals";
  }
  protected:
  explicit EgmTestSignals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalsFieldNumber = 1,
  };
  // repeated double signals = 1;
  int signals_size() const;
  private:
  int _internal_signals_size() const;
  public:
  void clear_signals();
  private:
  double _internal_signals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_signals() const;
  void _internal_add_signals(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_signals();
  public:
  double signals(int index) const;
  void set_signals(int index, double value);
  void add_signals(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      signals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_signals();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmTestSignals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > signals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmMeasuredForce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMeasuredForce) */ {
 public:
  inline EgmMeasuredForce() : EgmMeasuredForce(nullptr) {}
  ~EgmMeasuredForce() override;
  explicit PROTOBUF_CONSTEXPR EgmMeasuredForce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmMeasuredForce(const EgmMeasuredForce& from);
  EgmMeasuredForce(EgmMeasuredForce&& from) noexcept
    : EgmMeasuredForce() {
    *this = ::std::move(from);
  }

  inline EgmMeasuredForce& operator=(const EgmMeasuredForce& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmMeasuredForce& operator=(EgmMeasuredForce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmMeasuredForce& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmMeasuredForce* internal_default_instance() {
    return reinterpret_cast<const EgmMeasuredForce*>(
               &_EgmMeasuredForce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EgmMeasuredForce& a, EgmMeasuredForce& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmMeasuredForce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmMeasuredForce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmMeasuredForce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmMeasuredForce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmMeasuredForce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmMeasuredForce& from) {
    EgmMeasuredForce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmMeasuredForce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmMeasuredForce";
  }
  protected:
  explicit EgmMeasuredForce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 2,
    kFcActiveFieldNumber = 1,
  };
  // repeated double force = 2;
  int force_size() const;
  private:
  int _internal_force_size() const;
  public:
  void clear_force();
  private:
  double _internal_force(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_force() const;
  void _internal_add_force(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_force();
  public:
  double force(int index) const;
  void set_force(int index, double value);
  void add_force(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      force() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_force();

  // optional bool fcActive = 1;
  bool has_fcactive() const;
  private:
  bool _internal_has_fcactive() const;
  public:
  void clear_fcactive();
  bool fcactive() const;
  void set_fcactive(bool value);
  private:
  bool _internal_fcactive() const;
  void _internal_set_fcactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMeasuredForce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > force_;
    bool fcactive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmCollisionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCollisionInfo) */ {
 public:
  inline EgmCollisionInfo() : EgmCollisionInfo(nullptr) {}
  ~EgmCollisionInfo() override;
  explicit PROTOBUF_CONSTEXPR EgmCollisionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmCollisionInfo(const EgmCollisionInfo& from);
  EgmCollisionInfo(EgmCollisionInfo&& from) noexcept
    : EgmCollisionInfo() {
    *this = ::std::move(from);
  }

  inline EgmCollisionInfo& operator=(const EgmCollisionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmCollisionInfo& operator=(EgmCollisionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmCollisionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmCollisionInfo* internal_default_instance() {
    return reinterpret_cast<const EgmCollisionInfo*>(
               &_EgmCollisionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EgmCollisionInfo& a, EgmCollisionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmCollisionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmCollisionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmCollisionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmCollisionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmCollisionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmCollisionInfo& from) {
    EgmCollisionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmCollisionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmCollisionInfo";
  }
  protected:
  explicit EgmCollisionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollDetQuotaFieldNumber = 2,
    kCollsionTriggeredFieldNumber = 1,
  };
  // repeated double collDetQuota = 2;
  int colldetquota_size() const;
  private:
  int _internal_colldetquota_size() const;
  public:
  void clear_colldetquota();
  private:
  double _internal_colldetquota(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_colldetquota() const;
  void _internal_add_colldetquota(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_colldetquota();
  public:
  double colldetquota(int index) const;
  void set_colldetquota(int index, double value);
  void add_colldetquota(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      colldetquota() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_colldetquota();

  // optional bool collsionTriggered = 1;
  bool has_collsiontriggered() const;
  private:
  bool _internal_has_collsiontriggered() const;
  public:
  void clear_collsiontriggered();
  bool collsiontriggered() const;
  void set_collsiontriggered(bool value);
  private:
  bool _internal_collsiontriggered() const;
  void _internal_set_collsiontriggered(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCollisionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > colldetquota_;
    bool collsiontriggered_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmRAPIDdata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRAPIDdata) */ {
 public:
  inline EgmRAPIDdata() : EgmRAPIDdata(nullptr) {}
  ~EgmRAPIDdata() override;
  explicit PROTOBUF_CONSTEXPR EgmRAPIDdata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmRAPIDdata(const EgmRAPIDdata& from);
  EgmRAPIDdata(EgmRAPIDdata&& from) noexcept
    : EgmRAPIDdata() {
    *this = ::std::move(from);
  }

  inline EgmRAPIDdata& operator=(const EgmRAPIDdata& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRAPIDdata& operator=(EgmRAPIDdata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmRAPIDdata& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmRAPIDdata* internal_default_instance() {
    return reinterpret_cast<const EgmRAPIDdata*>(
               &_EgmRAPIDdata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EgmRAPIDdata& a, EgmRAPIDdata& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRAPIDdata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRAPIDdata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmRAPIDdata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmRAPIDdata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmRAPIDdata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmRAPIDdata& from) {
    EgmRAPIDdata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmRAPIDdata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmRAPIDdata";
  }
  protected:
  explicit EgmRAPIDdata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnumFieldNumber = 2,
    kDigValFieldNumber = 1,
  };
  // repeated double dnum = 2;
  int dnum_size() const;
  private:
  int _internal_dnum_size() const;
  public:
  void clear_dnum();
  private:
  double _internal_dnum(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_dnum() const;
  void _internal_add_dnum(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_dnum();
  public:
  double dnum(int index) const;
  void set_dnum(int index, double value);
  void add_dnum(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      dnum() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_dnum();

  // optional bool digVal = 1;
  bool has_digval() const;
  private:
  bool _internal_has_digval() const;
  public:
  void clear_digval();
  bool digval() const;
  void set_digval(bool value);
  private:
  bool _internal_digval() const;
  void _internal_set_digval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRAPIDdata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > dnum_;
    bool digval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmRobot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRobot) */ {
 public:
  inline EgmRobot() : EgmRobot(nullptr) {}
  ~EgmRobot() override;
  explicit PROTOBUF_CONSTEXPR EgmRobot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmRobot(const EgmRobot& from);
  EgmRobot(EgmRobot&& from) noexcept
    : EgmRobot() {
    *this = ::std::move(from);
  }

  inline EgmRobot& operator=(const EgmRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmRobot& operator=(EgmRobot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmRobot& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmRobot* internal_default_instance() {
    return reinterpret_cast<const EgmRobot*>(
               &_EgmRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EgmRobot& a, EgmRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmRobot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmRobot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmRobot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmRobot& from) {
    EgmRobot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmRobot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmRobot";
  }
  protected:
  explicit EgmRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFeedBackFieldNumber = 2,
    kPlannedFieldNumber = 3,
    kMotorStateFieldNumber = 4,
    kMciStateFieldNumber = 5,
    kTestSignalsFieldNumber = 7,
    kRapidExecStateFieldNumber = 8,
    kMeasuredForceFieldNumber = 9,
    kCollisionInfoFieldNumber = 12,
    kRAPIDfromRobotFieldNumber = 13,
    kMciConvergenceMetFieldNumber = 6,
    kMoveIndexFieldNumber = 11,
    kUtilizationRateFieldNumber = 10,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::abb::egm::EgmFeedBack& feedback() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmFeedBack* release_feedback();
  ::abb::egm::EgmFeedBack* mutable_feedback();
  void set_allocated_feedback(::abb::egm::EgmFeedBack* feedback);
  private:
  const ::abb::egm::EgmFeedBack& _internal_feedback() const;
  ::abb::egm::EgmFeedBack* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::abb::egm::EgmFeedBack* feedback);
  ::abb::egm::EgmFeedBack* unsafe_arena_release_feedback();

  // optional .abb.egm.EgmPlanned planned = 3;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::EgmPlanned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);
  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::EgmPlanned* planned);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  // optional .abb.egm.EgmMotorState motorState = 4;
  bool has_motorstate() const;
  private:
  bool _internal_has_motorstate() const;
  public:
  void clear_motorstate();
  const ::abb::egm::EgmMotorState& motorstate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMotorState* release_motorstate();
  ::abb::egm::EgmMotorState* mutable_motorstate();
  void set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate);
  private:
  const ::abb::egm::EgmMotorState& _internal_motorstate() const;
  ::abb::egm::EgmMotorState* _internal_mutable_motorstate();
  public:
  void unsafe_arena_set_allocated_motorstate(
      ::abb::egm::EgmMotorState* motorstate);
  ::abb::egm::EgmMotorState* unsafe_arena_release_motorstate();

  // optional .abb.egm.EgmMCIState mciState = 5;
  bool has_mcistate() const;
  private:
  bool _internal_has_mcistate() const;
  public:
  void clear_mcistate();
  const ::abb::egm::EgmMCIState& mcistate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMCIState* release_mcistate();
  ::abb::egm::EgmMCIState* mutable_mcistate();
  void set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate);
  private:
  const ::abb::egm::EgmMCIState& _internal_mcistate() const;
  ::abb::egm::EgmMCIState* _internal_mutable_mcistate();
  public:
  void unsafe_arena_set_allocated_mcistate(
      ::abb::egm::EgmMCIState* mcistate);
  ::abb::egm::EgmMCIState* unsafe_arena_release_mcistate();

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  bool has_testsignals() const;
  private:
  bool _internal_has_testsignals() const;
  public:
  void clear_testsignals();
  const ::abb::egm::EgmTestSignals& testsignals() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmTestSignals* release_testsignals();
  ::abb::egm::EgmTestSignals* mutable_testsignals();
  void set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals);
  private:
  const ::abb::egm::EgmTestSignals& _internal_testsignals() const;
  ::abb::egm::EgmTestSignals* _internal_mutable_testsignals();
  public:
  void unsafe_arena_set_allocated_testsignals(
      ::abb::egm::EgmTestSignals* testsignals);
  ::abb::egm::EgmTestSignals* unsafe_arena_release_testsignals();

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  bool has_rapidexecstate() const;
  private:
  bool _internal_has_rapidexecstate() const;
  public:
  void clear_rapidexecstate();
  const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmRapidCtrlExecState* release_rapidexecstate();
  ::abb::egm::EgmRapidCtrlExecState* mutable_rapidexecstate();
  void set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate);
  private:
  const ::abb::egm::EgmRapidCtrlExecState& _internal_rapidexecstate() const;
  ::abb::egm::EgmRapidCtrlExecState* _internal_mutable_rapidexecstate();
  public:
  void unsafe_arena_set_allocated_rapidexecstate(
      ::abb::egm::EgmRapidCtrlExecState* rapidexecstate);
  ::abb::egm::EgmRapidCtrlExecState* unsafe_arena_release_rapidexecstate();

  // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
  bool has_measuredforce() const;
  private:
  bool _internal_has_measuredforce() const;
  public:
  void clear_measuredforce();
  const ::abb::egm::EgmMeasuredForce& measuredforce() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmMeasuredForce* release_measuredforce();
  ::abb::egm::EgmMeasuredForce* mutable_measuredforce();
  void set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* measuredforce);
  private:
  const ::abb::egm::EgmMeasuredForce& _internal_measuredforce() const;
  ::abb::egm::EgmMeasuredForce* _internal_mutable_measuredforce();
  public:
  void unsafe_arena_set_allocated_measuredforce(
      ::abb::egm::EgmMeasuredForce* measuredforce);
  ::abb::egm::EgmMeasuredForce* unsafe_arena_release_measuredforce();

  // optional .abb.egm.EgmCollisionInfo CollisionInfo = 12;
  bool has_collisioninfo() const;
  private:
  bool _internal_has_collisioninfo() const;
  public:
  void clear_collisioninfo();
  const ::abb::egm::EgmCollisionInfo& collisioninfo() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmCollisionInfo* release_collisioninfo();
  ::abb::egm::EgmCollisionInfo* mutable_collisioninfo();
  void set_allocated_collisioninfo(::abb::egm::EgmCollisionInfo* collisioninfo);
  private:
  const ::abb::egm::EgmCollisionInfo& _internal_collisioninfo() const;
  ::abb::egm::EgmCollisionInfo* _internal_mutable_collisioninfo();
  public:
  void unsafe_arena_set_allocated_collisioninfo(
      ::abb::egm::EgmCollisionInfo* collisioninfo);
  ::abb::egm::EgmCollisionInfo* unsafe_arena_release_collisioninfo();

  // optional .abb.egm.EgmRAPIDdata RAPIDfromRobot = 13;
  bool has_rapidfromrobot() const;
  private:
  bool _internal_has_rapidfromrobot() const;
  public:
  void clear_rapidfromrobot();
  const ::abb::egm::EgmRAPIDdata& rapidfromrobot() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmRAPIDdata* release_rapidfromrobot();
  ::abb::egm::EgmRAPIDdata* mutable_rapidfromrobot();
  void set_allocated_rapidfromrobot(::abb::egm::EgmRAPIDdata* rapidfromrobot);
  private:
  const ::abb::egm::EgmRAPIDdata& _internal_rapidfromrobot() const;
  ::abb::egm::EgmRAPIDdata* _internal_mutable_rapidfromrobot();
  public:
  void unsafe_arena_set_allocated_rapidfromrobot(
      ::abb::egm::EgmRAPIDdata* rapidfromrobot);
  ::abb::egm::EgmRAPIDdata* unsafe_arena_release_rapidfromrobot();

  // optional bool mciConvergenceMet = 6;
  bool has_mciconvergencemet() const;
  private:
  bool _internal_has_mciconvergencemet() const;
  public:
  void clear_mciconvergencemet();
  bool mciconvergencemet() const;
  void set_mciconvergencemet(bool value);
  private:
  bool _internal_mciconvergencemet() const;
  void _internal_set_mciconvergencemet(bool value);
  public:

  // optional uint32 moveIndex = 11;
  bool has_moveindex() const;
  private:
  bool _internal_has_moveindex() const;
  public:
  void clear_moveindex();
  uint32_t moveindex() const;
  void set_moveindex(uint32_t value);
  private:
  uint32_t _internal_moveindex() const;
  void _internal_set_moveindex(uint32_t value);
  public:

  // optional double utilizationRate = 10;
  bool has_utilizationrate() const;
  private:
  bool _internal_has_utilizationrate() const;
  public:
  void clear_utilizationrate();
  double utilizationrate() const;
  void set_utilizationrate(double value);
  private:
  double _internal_utilizationrate() const;
  void _internal_set_utilizationrate(double value);
  public:

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRobot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmFeedBack* feedback_;
    ::abb::egm::EgmPlanned* planned_;
    ::abb::egm::EgmMotorState* motorstate_;
    ::abb::egm::EgmMCIState* mcistate_;
    ::abb::egm::EgmTestSignals* testsignals_;
    ::abb::egm::EgmRapidCtrlExecState* rapidexecstate_;
    ::abb::egm::EgmMeasuredForce* measuredforce_;
    ::abb::egm::EgmCollisionInfo* collisioninfo_;
    ::abb::egm::EgmRAPIDdata* rapidfromrobot_;
    bool mciconvergencemet_;
    uint32_t moveindex_;
    double utilizationrate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensor) */ {
 public:
  inline EgmSensor() : EgmSensor(nullptr) {}
  ~EgmSensor() override;
  explicit PROTOBUF_CONSTEXPR EgmSensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmSensor(const EgmSensor& from);
  EgmSensor(EgmSensor&& from) noexcept
    : EgmSensor() {
    *this = ::std::move(from);
  }

  inline EgmSensor& operator=(const EgmSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensor& operator=(EgmSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSensor* internal_default_instance() {
    return reinterpret_cast<const EgmSensor*>(
               &_EgmSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EgmSensor& a, EgmSensor& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmSensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmSensor& from) {
    EgmSensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSensor";
  }
  protected:
  explicit EgmSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPlannedFieldNumber = 2,
    kSpeedRefFieldNumber = 3,
    kRAPIDtoRobotFieldNumber = 4,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmPlanned planned = 2;
  bool has_planned() const;
  private:
  bool _internal_has_planned() const;
  public:
  void clear_planned();
  const ::abb::egm::EgmPlanned& planned() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPlanned* release_planned();
  ::abb::egm::EgmPlanned* mutable_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);
  private:
  const ::abb::egm::EgmPlanned& _internal_planned() const;
  ::abb::egm::EgmPlanned* _internal_mutable_planned();
  public:
  void unsafe_arena_set_allocated_planned(
      ::abb::egm::EgmPlanned* planned);
  ::abb::egm::EgmPlanned* unsafe_arena_release_planned();

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  bool has_speedref() const;
  private:
  bool _internal_has_speedref() const;
  public:
  void clear_speedref();
  const ::abb::egm::EgmSpeedRef& speedref() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmSpeedRef* release_speedref();
  ::abb::egm::EgmSpeedRef* mutable_speedref();
  void set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref);
  private:
  const ::abb::egm::EgmSpeedRef& _internal_speedref() const;
  ::abb::egm::EgmSpeedRef* _internal_mutable_speedref();
  public:
  void unsafe_arena_set_allocated_speedref(
      ::abb::egm::EgmSpeedRef* speedref);
  ::abb::egm::EgmSpeedRef* unsafe_arena_release_speedref();

  // optional .abb.egm.EgmRAPIDdata RAPIDtoRobot = 4;
  bool has_rapidtorobot() const;
  private:
  bool _internal_has_rapidtorobot() const;
  public:
  void clear_rapidtorobot();
  const ::abb::egm::EgmRAPIDdata& rapidtorobot() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmRAPIDdata* release_rapidtorobot();
  ::abb::egm::EgmRAPIDdata* mutable_rapidtorobot();
  void set_allocated_rapidtorobot(::abb::egm::EgmRAPIDdata* rapidtorobot);
  private:
  const ::abb::egm::EgmRAPIDdata& _internal_rapidtorobot() const;
  ::abb::egm::EgmRAPIDdata* _internal_mutable_rapidtorobot();
  public:
  void unsafe_arena_set_allocated_rapidtorobot(
      ::abb::egm::EgmRAPIDdata* rapidtorobot);
  ::abb::egm::EgmRAPIDdata* unsafe_arena_release_rapidtorobot();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmPlanned* planned_;
    ::abb::egm::EgmSpeedRef* speedref_;
    ::abb::egm::EgmRAPIDdata* rapidtorobot_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// -------------------------------------------------------------------

class EgmSensorPathCorr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensorPathCorr) */ {
 public:
  inline EgmSensorPathCorr() : EgmSensorPathCorr(nullptr) {}
  ~EgmSensorPathCorr() override;
  explicit PROTOBUF_CONSTEXPR EgmSensorPathCorr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgmSensorPathCorr(const EgmSensorPathCorr& from);
  EgmSensorPathCorr(EgmSensorPathCorr&& from) noexcept
    : EgmSensorPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmSensorPathCorr& operator=(const EgmSensorPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgmSensorPathCorr& operator=(EgmSensorPathCorr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgmSensorPathCorr& default_instance() {
    return *internal_default_instance();
  }
  static inline const EgmSensorPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmSensorPathCorr*>(
               &_EgmSensorPathCorr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EgmSensorPathCorr& a, EgmSensorPathCorr& b) {
    a.Swap(&b);
  }
  inline void Swap(EgmSensorPathCorr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgmSensorPathCorr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgmSensorPathCorr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgmSensorPathCorr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgmSensorPathCorr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgmSensorPathCorr& from) {
    EgmSensorPathCorr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgmSensorPathCorr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abb.egm.EgmSensorPathCorr";
  }
  protected:
  explicit EgmSensorPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPathCorrFieldNumber = 2,
  };
  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::abb::egm::EgmHeader& header() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmHeader* release_header();
  ::abb::egm::EgmHeader* mutable_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);
  private:
  const ::abb::egm::EgmHeader& _internal_header() const;
  ::abb::egm::EgmHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::abb::egm::EgmHeader* header);
  ::abb::egm::EgmHeader* unsafe_arena_release_header();

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  bool has_pathcorr() const;
  private:
  bool _internal_has_pathcorr() const;
  public:
  void clear_pathcorr();
  const ::abb::egm::EgmPathCorr& pathcorr() const;
  PROTOBUF_NODISCARD ::abb::egm::EgmPathCorr* release_pathcorr();
  ::abb::egm::EgmPathCorr* mutable_pathcorr();
  void set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr);
  private:
  const ::abb::egm::EgmPathCorr& _internal_pathcorr() const;
  ::abb::egm::EgmPathCorr* _internal_mutable_pathcorr();
  public:
  void unsafe_arena_set_allocated_pathcorr(
      ::abb::egm::EgmPathCorr* pathcorr);
  ::abb::egm::EgmPathCorr* unsafe_arena_release_pathcorr();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensorPathCorr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abb::egm::EgmHeader* header_;
    ::abb::egm::EgmPathCorr* pathcorr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_egm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EgmHeader

// optional uint32 seqno = 1;
inline bool EgmHeader::_internal_has_seqno() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmHeader::has_seqno() const {
  return _internal_has_seqno();
}
inline void EgmHeader::clear_seqno() {
  _impl_.seqno_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t EgmHeader::_internal_seqno() const {
  return _impl_.seqno_;
}
inline uint32_t EgmHeader::seqno() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.seqno)
  return _internal_seqno();
}
inline void EgmHeader::_internal_set_seqno(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seqno_ = value;
}
inline void EgmHeader::set_seqno(uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.seqno)
}

// optional uint32 tm = 2;
inline bool EgmHeader::_internal_has_tm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmHeader::has_tm() const {
  return _internal_has_tm();
}
inline void EgmHeader::clear_tm() {
  _impl_.tm_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EgmHeader::_internal_tm() const {
  return _impl_.tm_;
}
inline uint32_t EgmHeader::tm() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.tm)
  return _internal_tm();
}
inline void EgmHeader::_internal_set_tm(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tm_ = value;
}
inline void EgmHeader::set_tm(uint32_t value) {
  _internal_set_tm(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.tm)
}

// optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
inline bool EgmHeader::_internal_has_mtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmHeader::has_mtype() const {
  return _internal_has_mtype();
}
inline void EgmHeader::clear_mtype() {
  _impl_.mtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::_internal_mtype() const {
  return static_cast< ::abb::egm::EgmHeader_MessageType >(_impl_.mtype_);
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::mtype() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.mtype)
  return _internal_mtype();
}
inline void EgmHeader::_internal_set_mtype(::abb::egm::EgmHeader_MessageType value) {
  assert(::abb::egm::EgmHeader_MessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mtype_ = value;
}
inline void EgmHeader::set_mtype(::abb::egm::EgmHeader_MessageType value) {
  _internal_set_mtype(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.mtype)
}

// -------------------------------------------------------------------

// EgmCartesian

// required double x = 1;
inline bool EgmCartesian::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmCartesian::has_x() const {
  return _internal_has_x();
}
inline void EgmCartesian::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmCartesian::_internal_x() const {
  return _impl_.x_;
}
inline double EgmCartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.x)
  return _internal_x();
}
inline void EgmCartesian::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void EgmCartesian::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.x)
}

// required double y = 2;
inline bool EgmCartesian::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmCartesian::has_y() const {
  return _internal_has_y();
}
inline void EgmCartesian::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmCartesian::_internal_y() const {
  return _impl_.y_;
}
inline double EgmCartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.y)
  return _internal_y();
}
inline void EgmCartesian::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void EgmCartesian::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.y)
}

// required double z = 3;
inline bool EgmCartesian::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmCartesian::has_z() const {
  return _internal_has_z();
}
inline void EgmCartesian::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmCartesian::_internal_z() const {
  return _impl_.z_;
}
inline double EgmCartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.z)
  return _internal_z();
}
inline void EgmCartesian::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void EgmCartesian::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.z)
}

// -------------------------------------------------------------------

// EgmQuaternion

// required double u0 = 1;
inline bool EgmQuaternion::_internal_has_u0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u0() const {
  return _internal_has_u0();
}
inline void EgmQuaternion::clear_u0() {
  _impl_.u0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmQuaternion::_internal_u0() const {
  return _impl_.u0_;
}
inline double EgmQuaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u0)
  return _internal_u0();
}
inline void EgmQuaternion::_internal_set_u0(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u0_ = value;
}
inline void EgmQuaternion::set_u0(double value) {
  _internal_set_u0(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u0)
}

// required double u1 = 2;
inline bool EgmQuaternion::_internal_has_u1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u1() const {
  return _internal_has_u1();
}
inline void EgmQuaternion::clear_u1() {
  _impl_.u1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmQuaternion::_internal_u1() const {
  return _impl_.u1_;
}
inline double EgmQuaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u1)
  return _internal_u1();
}
inline void EgmQuaternion::_internal_set_u1(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.u1_ = value;
}
inline void EgmQuaternion::set_u1(double value) {
  _internal_set_u1(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u1)
}

// required double u2 = 3;
inline bool EgmQuaternion::_internal_has_u2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u2() const {
  return _internal_has_u2();
}
inline void EgmQuaternion::clear_u2() {
  _impl_.u2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmQuaternion::_internal_u2() const {
  return _impl_.u2_;
}
inline double EgmQuaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u2)
  return _internal_u2();
}
inline void EgmQuaternion::_internal_set_u2(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.u2_ = value;
}
inline void EgmQuaternion::set_u2(double value) {
  _internal_set_u2(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u2)
}

// required double u3 = 4;
inline bool EgmQuaternion::_internal_has_u3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EgmQuaternion::has_u3() const {
  return _internal_has_u3();
}
inline void EgmQuaternion::clear_u3() {
  _impl_.u3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double EgmQuaternion::_internal_u3() const {
  return _impl_.u3_;
}
inline double EgmQuaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u3)
  return _internal_u3();
}
inline void EgmQuaternion::_internal_set_u3(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.u3_ = value;
}
inline void EgmQuaternion::set_u3(double value) {
  _internal_set_u3(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u3)
}

// -------------------------------------------------------------------

// EgmEuler

// required double x = 1;
inline bool EgmEuler::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmEuler::has_x() const {
  return _internal_has_x();
}
inline void EgmEuler::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double EgmEuler::_internal_x() const {
  return _impl_.x_;
}
inline double EgmEuler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.x)
  return _internal_x();
}
inline void EgmEuler::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void EgmEuler::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.x)
}

// required double y = 2;
inline bool EgmEuler::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmEuler::has_y() const {
  return _internal_has_y();
}
inline void EgmEuler::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double EgmEuler::_internal_y() const {
  return _impl_.y_;
}
inline double EgmEuler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.y)
  return _internal_y();
}
inline void EgmEuler::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void EgmEuler::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.y)
}

// required double z = 3;
inline bool EgmEuler::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EgmEuler::has_z() const {
  return _internal_has_z();
}
inline void EgmEuler::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double EgmEuler::_internal_z() const {
  return _impl_.z_;
}
inline double EgmEuler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.z)
  return _internal_z();
}
inline void EgmEuler::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void EgmEuler::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.z)
}

// -------------------------------------------------------------------

// EgmClock

// required uint64 sec = 1;
inline bool EgmClock::_internal_has_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmClock::has_sec() const {
  return _internal_has_sec();
}
inline void EgmClock::clear_sec() {
  _impl_.sec_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t EgmClock::_internal_sec() const {
  return _impl_.sec_;
}
inline uint64_t EgmClock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.sec)
  return _internal_sec();
}
inline void EgmClock::_internal_set_sec(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sec_ = value;
}
inline void EgmClock::set_sec(uint64_t value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.sec)
}

// required uint64 usec = 2;
inline bool EgmClock::_internal_has_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmClock::has_usec() const {
  return _internal_has_usec();
}
inline void EgmClock::clear_usec() {
  _impl_.usec_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t EgmClock::_internal_usec() const {
  return _impl_.usec_;
}
inline uint64_t EgmClock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmClock.usec)
  return _internal_usec();
}
inline void EgmClock::_internal_set_usec(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usec_ = value;
}
inline void EgmClock::set_usec(uint64_t value) {
  _internal_set_usec(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmClock.usec)
}

// -------------------------------------------------------------------

// EgmPose

// optional .abb.egm.EgmCartesian pos = 1;
inline bool EgmPose::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool EgmPose::has_pos() const {
  return _internal_has_pos();
}
inline void EgmPose::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPose::_internal_pos() const {
  const ::abb::egm::EgmCartesian* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(
      ::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPose::pos() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.pos)
  return _internal_pos();
}
inline void EgmPose::unsafe_arena_set_allocated_pos(
    ::abb::egm::EgmCartesian* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.pos)
}
inline ::abb::egm::EgmCartesian* EgmPose::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPose::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPose::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::abb::egm::EgmCartesian* EgmPose::mutable_pos() {
  ::abb::egm::EgmCartesian* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.pos)
  return _msg;
}
inline void EgmPose::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.pos)
}

// optional .abb.egm.EgmQuaternion orient = 2;
inline bool EgmPose::_internal_has_orient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orient_ != nullptr);
  return value;
}
inline bool EgmPose::has_orient() const {
  return _internal_has_orient();
}
inline void EgmPose::clear_orient() {
  if (_impl_.orient_ != nullptr) _impl_.orient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmQuaternion& EgmPose::_internal_orient() const {
  const ::abb::egm::EgmQuaternion* p = _impl_.orient_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmQuaternion&>(
      ::abb::egm::_EgmQuaternion_default_instance_);
}
inline const ::abb::egm::EgmQuaternion& EgmPose::orient() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.orient)
  return _internal_orient();
}
inline void EgmPose::unsafe_arena_set_allocated_orient(
    ::abb::egm::EgmQuaternion* orient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orient_);
  }
  _impl_.orient_ = orient;
  if (orient) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.orient)
}
inline ::abb::egm::EgmQuaternion* EgmPose::release_orient() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* temp = _impl_.orient_;
  _impl_.orient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmQuaternion* EgmPose::unsafe_arena_release_orient() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.orient)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmQuaternion* temp = _impl_.orient_;
  _impl_.orient_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmQuaternion* EgmPose::_internal_mutable_orient() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orient_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmQuaternion>(GetArenaForAllocation());
    _impl_.orient_ = p;
  }
  return _impl_.orient_;
}
inline ::abb::egm::EgmQuaternion* EgmPose::mutable_orient() {
  ::abb::egm::EgmQuaternion* _msg = _internal_mutable_orient();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.orient)
  return _msg;
}
inline void EgmPose::set_allocated_orient(::abb::egm::EgmQuaternion* orient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orient_;
  }
  if (orient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orient);
    if (message_arena != submessage_arena) {
      orient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orient, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.orient_ = orient;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.orient)
}

// optional .abb.egm.EgmEuler euler = 3;
inline bool EgmPose::_internal_has_euler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.euler_ != nullptr);
  return value;
}
inline bool EgmPose::has_euler() const {
  return _internal_has_euler();
}
inline void EgmPose::clear_euler() {
  if (_impl_.euler_ != nullptr) _impl_.euler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmEuler& EgmPose::_internal_euler() const {
  const ::abb::egm::EgmEuler* p = _impl_.euler_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmEuler&>(
      ::abb::egm::_EgmEuler_default_instance_);
}
inline const ::abb::egm::EgmEuler& EgmPose::euler() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.euler)
  return _internal_euler();
}
inline void EgmPose::unsafe_arena_set_allocated_euler(
    ::abb::egm::EgmEuler* euler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.euler_);
  }
  _impl_.euler_ = euler;
  if (euler) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPose.euler)
}
inline ::abb::egm::EgmEuler* EgmPose::release_euler() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmEuler* EgmPose::unsafe_arena_release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.euler)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmEuler* temp = _impl_.euler_;
  _impl_.euler_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmEuler* EgmPose::_internal_mutable_euler() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.euler_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmEuler>(GetArenaForAllocation());
    _impl_.euler_ = p;
  }
  return _impl_.euler_;
}
inline ::abb::egm::EgmEuler* EgmPose::mutable_euler() {
  ::abb::egm::EgmEuler* _msg = _internal_mutable_euler();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.euler)
  return _msg;
}
inline void EgmPose::set_allocated_euler(::abb::egm::EgmEuler* euler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.euler_;
  }
  if (euler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(euler);
    if (message_arena != submessage_arena) {
      euler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.euler_ = euler;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.euler)
}

// -------------------------------------------------------------------

// EgmCartesianSpeed

// repeated double value = 1;
inline int EgmCartesianSpeed::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int EgmCartesianSpeed::value_size() const {
  return _internal_value_size();
}
inline void EgmCartesianSpeed::clear_value() {
  _impl_.value_.Clear();
}
inline double EgmCartesianSpeed::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline double EgmCartesianSpeed::value(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesianSpeed.value)
  return _internal_value(index);
}
inline void EgmCartesianSpeed::set_value(int index, double value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesianSpeed.value)
}
inline void EgmCartesianSpeed::_internal_add_value(double value) {
  _impl_.value_.Add(value);
}
inline void EgmCartesianSpeed::add_value(double value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmCartesianSpeed.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCartesianSpeed::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCartesianSpeed::value() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmCartesianSpeed.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCartesianSpeed::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCartesianSpeed::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmCartesianSpeed.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// EgmJoints

// repeated double joints = 1;
inline int EgmJoints::_internal_joints_size() const {
  return _impl_.joints_.size();
}
inline int EgmJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmJoints::clear_joints() {
  _impl_.joints_.Clear();
}
inline double EgmJoints::_internal_joints(int index) const {
  return _impl_.joints_.Get(index);
}
inline double EgmJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmJoints.joints)
  return _internal_joints(index);
}
inline void EgmJoints::set_joints(int index, double value) {
  _impl_.joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmJoints.joints)
}
inline void EgmJoints::_internal_add_joints(double value) {
  _impl_.joints_.Add(value);
}
inline void EgmJoints::add_joints(double value) {
  _internal_add_joints(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmJoints.joints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmJoints::_internal_joints() const {
  return _impl_.joints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmJoints.joints)
  return _internal_joints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmJoints::_internal_mutable_joints() {
  return &_impl_.joints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmJoints.joints)
  return _internal_mutable_joints();
}

// -------------------------------------------------------------------

// EgmExternalJoints

// repeated double joints = 1;
inline int EgmExternalJoints::_internal_joints_size() const {
  return _impl_.joints_.size();
}
inline int EgmExternalJoints::joints_size() const {
  return _internal_joints_size();
}
inline void EgmExternalJoints::clear_joints() {
  _impl_.joints_.Clear();
}
inline double EgmExternalJoints::_internal_joints(int index) const {
  return _impl_.joints_.Get(index);
}
inline double EgmExternalJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmExternalJoints.joints)
  return _internal_joints(index);
}
inline void EgmExternalJoints::set_joints(int index, double value) {
  _impl_.joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmExternalJoints.joints)
}
inline void EgmExternalJoints::_internal_add_joints(double value) {
  _impl_.joints_.Add(value);
}
inline void EgmExternalJoints::add_joints(double value) {
  _internal_add_joints(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmExternalJoints.joints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmExternalJoints::_internal_joints() const {
  return _impl_.joints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmExternalJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmExternalJoints.joints)
  return _internal_joints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmExternalJoints::_internal_mutable_joints() {
  return &_impl_.joints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmExternalJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmExternalJoints.joints)
  return _internal_mutable_joints();
}

// -------------------------------------------------------------------

// EgmPlanned

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmPlanned::_internal_has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_joints() const {
  return _internal_has_joints();
}
inline void EgmPlanned::clear_joints() {
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.joints)
  return _internal_joints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = joints;
  if (joints) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.joints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_joints() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.joints)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_joints() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.joints_ = p;
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_joints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.joints)
  return _msg;
}
inline void EgmPlanned::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmPlanned::_internal_has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void EgmPlanned::clear_cartesian() {
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmPlanned::_internal_cartesian() const {
  const ::abb::egm::EgmPose* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(
      ::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmPlanned::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.cartesian)
  return _internal_cartesian();
}
inline void EgmPlanned::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::EgmPose* cartesian) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = cartesian;
  if (cartesian) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.cartesian)
}
inline ::abb::egm::EgmPose* EgmPlanned::release_cartesian() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmPose* EgmPlanned::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.cartesian)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmPlanned::_internal_mutable_cartesian() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArenaForAllocation());
    _impl_.cartesian_ = p;
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::EgmPose* EgmPlanned::mutable_cartesian() {
  ::abb::egm::EgmPose* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.cartesian)
  return _msg;
}
inline void EgmPlanned::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmPlanned::_internal_has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmPlanned::clear_externaljoints() {
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmPlanned::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmPlanned::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.externalJoints)
  return _internal_externaljoints();
}
inline void EgmPlanned::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = externaljoints;
  if (externaljoints) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_externaljoints() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.externalJoints)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmPlanned::_internal_mutable_externaljoints() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.externaljoints_ = p;
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_externaljoints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.externalJoints)
  return _msg;
}
inline void EgmPlanned::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmPlanned::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline bool EgmPlanned::has_time() const {
  return _internal_has_time();
}
inline void EgmPlanned::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmPlanned::_internal_time() const {
  const ::abb::egm::EgmClock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(
      ::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmPlanned::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.time)
  return _internal_time();
}
inline void EgmPlanned::unsafe_arena_set_allocated_time(
    ::abb::egm::EgmClock* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPlanned.time)
}
inline ::abb::egm::EgmClock* EgmPlanned::release_time() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmClock* EgmPlanned::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.time)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmPlanned::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::abb::egm::EgmClock* EgmPlanned::mutable_time() {
  ::abb::egm::EgmClock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.time)
  return _msg;
}
inline void EgmPlanned::set_allocated_time(::abb::egm::EgmClock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.time)
}

// -------------------------------------------------------------------

// EgmSpeedRef

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmSpeedRef::_internal_has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_joints() const {
  return _internal_has_joints();
}
inline void EgmSpeedRef::clear_joints() {
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.joints)
  return _internal_joints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = joints;
  if (joints) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.joints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_joints() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.joints)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_joints() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.joints_ = p;
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_joints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.joints)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.joints)
}

// optional .abb.egm.EgmCartesianSpeed cartesians = 2;
inline bool EgmSpeedRef::_internal_has_cartesians() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesians_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_cartesians() const {
  return _internal_has_cartesians();
}
inline void EgmSpeedRef::clear_cartesians() {
  if (_impl_.cartesians_ != nullptr) _impl_.cartesians_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::_internal_cartesians() const {
  const ::abb::egm::EgmCartesianSpeed* p = _impl_.cartesians_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesianSpeed&>(
      ::abb::egm::_EgmCartesianSpeed_default_instance_);
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::cartesians() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.cartesians)
  return _internal_cartesians();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_cartesians(
    ::abb::egm::EgmCartesianSpeed* cartesians) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cartesians_);
  }
  _impl_.cartesians_ = cartesians;
  if (cartesians) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::release_cartesians() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* temp = _impl_.cartesians_;
  _impl_.cartesians_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::unsafe_arena_release_cartesians() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.cartesians)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmCartesianSpeed* temp = _impl_.cartesians_;
  _impl_.cartesians_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::_internal_mutable_cartesians() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesians_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesianSpeed>(GetArenaForAllocation());
    _impl_.cartesians_ = p;
  }
  return _impl_.cartesians_;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::mutable_cartesians() {
  ::abb::egm::EgmCartesianSpeed* _msg = _internal_mutable_cartesians();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.cartesians)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cartesians_;
  }
  if (cartesians) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cartesians);
    if (message_arena != submessage_arena) {
      cartesians = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesians, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cartesians_ = cartesians;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmSpeedRef::_internal_has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline bool EgmSpeedRef::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmSpeedRef::clear_externaljoints() {
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.externalJoints)
  return _internal_externaljoints();
}
inline void EgmSpeedRef::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = externaljoints;
  if (externaljoints) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_externaljoints() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.externalJoints)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::_internal_mutable_externaljoints() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.externaljoints_ = p;
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_externaljoints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.externalJoints)
  return _msg;
}
inline void EgmSpeedRef::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}

// -------------------------------------------------------------------

// EgmPathCorr

// required .abb.egm.EgmCartesian pos = 1;
inline bool EgmPathCorr::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool EgmPathCorr::has_pos() const {
  return _internal_has_pos();
}
inline void EgmPathCorr::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::_internal_pos() const {
  const ::abb::egm::EgmCartesian* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCartesian&>(
      ::abb::egm::_EgmCartesian_default_instance_);
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::pos() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.pos)
  return _internal_pos();
}
inline void EgmPathCorr::unsafe_arena_set_allocated_pos(
    ::abb::egm::EgmCartesian* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmPathCorr.pos)
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPathCorr.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmCartesian* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCartesian>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::mutable_pos() {
  ::abb::egm::EgmCartesian* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPathCorr.pos)
  return _msg;
}
inline void EgmPathCorr::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPathCorr.pos)
}

// required uint32 age = 2;
inline bool EgmPathCorr::_internal_has_age() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EgmPathCorr::has_age() const {
  return _internal_has_age();
}
inline void EgmPathCorr::clear_age() {
  _impl_.age_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t EgmPathCorr::_internal_age() const {
  return _impl_.age_;
}
inline uint32_t EgmPathCorr::age() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.age)
  return _internal_age();
}
inline void EgmPathCorr::_internal_set_age(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.age_ = value;
}
inline void EgmPathCorr::set_age(uint32_t value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmPathCorr.age)
}

// -------------------------------------------------------------------

// EgmFeedBack

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmFeedBack::_internal_has_joints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joints_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_joints() const {
  return _internal_has_joints();
}
inline void EgmFeedBack::clear_joints() {
  if (_impl_.joints_ != nullptr) _impl_.joints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_joints() const {
  const ::abb::egm::EgmJoints* p = _impl_.joints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.joints)
  return _internal_joints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_joints(
    ::abb::egm::EgmJoints* joints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.joints_);
  }
  _impl_.joints_ = joints;
  if (joints) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.joints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_joints() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.joints)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmJoints* temp = _impl_.joints_;
  _impl_.joints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_joints() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.joints_ = p;
  }
  return _impl_.joints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_joints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_joints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.joints)
  return _msg;
}
inline void EgmFeedBack::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.joints_;
  }
  if (joints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(joints);
    if (message_arena != submessage_arena) {
      joints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmFeedBack::_internal_has_cartesian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cartesian_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_cartesian() const {
  return _internal_has_cartesian();
}
inline void EgmFeedBack::clear_cartesian() {
  if (_impl_.cartesian_ != nullptr) _impl_.cartesian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPose& EgmFeedBack::_internal_cartesian() const {
  const ::abb::egm::EgmPose* p = _impl_.cartesian_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPose&>(
      ::abb::egm::_EgmPose_default_instance_);
}
inline const ::abb::egm::EgmPose& EgmFeedBack::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.cartesian)
  return _internal_cartesian();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_cartesian(
    ::abb::egm::EgmPose* cartesian) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cartesian_);
  }
  _impl_.cartesian_ = cartesian;
  if (cartesian) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.cartesian)
}
inline ::abb::egm::EgmPose* EgmFeedBack::release_cartesian() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmPose* EgmFeedBack::unsafe_arena_release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.cartesian)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPose* temp = _impl_.cartesian_;
  _impl_.cartesian_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPose* EgmFeedBack::_internal_mutable_cartesian() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cartesian_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPose>(GetArenaForAllocation());
    _impl_.cartesian_ = p;
  }
  return _impl_.cartesian_;
}
inline ::abb::egm::EgmPose* EgmFeedBack::mutable_cartesian() {
  ::abb::egm::EgmPose* _msg = _internal_mutable_cartesian();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.cartesian)
  return _msg;
}
inline void EgmFeedBack::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cartesian_;
  }
  if (cartesian) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cartesian);
    if (message_arena != submessage_arena) {
      cartesian = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartesian, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cartesian_ = cartesian;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmFeedBack::_internal_has_externaljoints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaljoints_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_externaljoints() const {
  return _internal_has_externaljoints();
}
inline void EgmFeedBack::clear_externaljoints() {
  if (_impl_.externaljoints_ != nullptr) _impl_.externaljoints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::_internal_externaljoints() const {
  const ::abb::egm::EgmJoints* p = _impl_.externaljoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmJoints&>(
      ::abb::egm::_EgmJoints_default_instance_);
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::externaljoints() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.externalJoints)
  return _internal_externaljoints();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_externaljoints(
    ::abb::egm::EgmJoints* externaljoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externaljoints_);
  }
  _impl_.externaljoints_ = externaljoints;
  if (externaljoints) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_externaljoints() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::unsafe_arena_release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.externalJoints)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmJoints* temp = _impl_.externaljoints_;
  _impl_.externaljoints_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::_internal_mutable_externaljoints() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externaljoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmJoints>(GetArenaForAllocation());
    _impl_.externaljoints_ = p;
  }
  return _impl_.externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_externaljoints() {
  ::abb::egm::EgmJoints* _msg = _internal_mutable_externaljoints();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.externalJoints)
  return _msg;
}
inline void EgmFeedBack::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externaljoints_;
  }
  if (externaljoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externaljoints);
    if (message_arena != submessage_arena) {
      externaljoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaljoints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.externaljoints_ = externaljoints;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}

// optional .abb.egm.EgmClock time = 4;
inline bool EgmFeedBack::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline bool EgmFeedBack::has_time() const {
  return _internal_has_time();
}
inline void EgmFeedBack::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmClock& EgmFeedBack::_internal_time() const {
  const ::abb::egm::EgmClock* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmClock&>(
      ::abb::egm::_EgmClock_default_instance_);
}
inline const ::abb::egm::EgmClock& EgmFeedBack::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.time)
  return _internal_time();
}
inline void EgmFeedBack::unsafe_arena_set_allocated_time(
    ::abb::egm::EgmClock* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmFeedBack.time)
}
inline ::abb::egm::EgmClock* EgmFeedBack::release_time() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmClock* EgmFeedBack::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.time)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmClock* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmClock* EgmFeedBack::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmClock>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::abb::egm::EgmClock* EgmFeedBack::mutable_time() {
  ::abb::egm::EgmClock* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.time)
  return _msg;
}
inline void EgmFeedBack::set_allocated_time(::abb::egm::EgmClock* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.time)
}

// -------------------------------------------------------------------

// EgmMotorState

// required .abb.egm.EgmMotorState.MotorStateType state = 1;
inline bool EgmMotorState::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmMotorState::has_state() const {
  return _internal_has_state();
}
inline void EgmMotorState::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::_internal_state() const {
  return static_cast< ::abb::egm::EgmMotorState_MotorStateType >(_impl_.state_);
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMotorState.state)
  return _internal_state();
}
inline void EgmMotorState::_internal_set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  assert(::abb::egm::EgmMotorState_MotorStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}
inline void EgmMotorState::set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMotorState.state)
}

// -------------------------------------------------------------------

// EgmMCIState

// required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
inline bool EgmMCIState::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmMCIState::has_state() const {
  return _internal_has_state();
}
inline void EgmMCIState::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::_internal_state() const {
  return static_cast< ::abb::egm::EgmMCIState_MCIStateType >(_impl_.state_);
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMCIState.state)
  return _internal_state();
}
inline void EgmMCIState::_internal_set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  assert(::abb::egm::EgmMCIState_MCIStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}
inline void EgmMCIState::set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMCIState.state)
}

// -------------------------------------------------------------------

// EgmRapidCtrlExecState

// required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
inline bool EgmRapidCtrlExecState::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmRapidCtrlExecState::has_state() const {
  return _internal_has_state();
}
inline void EgmRapidCtrlExecState::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::_internal_state() const {
  return static_cast< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType >(_impl_.state_);
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRapidCtrlExecState.state)
  return _internal_state();
}
inline void EgmRapidCtrlExecState::_internal_set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  assert(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}
inline void EgmRapidCtrlExecState::set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRapidCtrlExecState.state)
}

// -------------------------------------------------------------------

// EgmTestSignals

// repeated double signals = 1;
inline int EgmTestSignals::_internal_signals_size() const {
  return _impl_.signals_.size();
}
inline int EgmTestSignals::signals_size() const {
  return _internal_signals_size();
}
inline void EgmTestSignals::clear_signals() {
  _impl_.signals_.Clear();
}
inline double EgmTestSignals::_internal_signals(int index) const {
  return _impl_.signals_.Get(index);
}
inline double EgmTestSignals::signals(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmTestSignals.signals)
  return _internal_signals(index);
}
inline void EgmTestSignals::set_signals(int index, double value) {
  _impl_.signals_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmTestSignals.signals)
}
inline void EgmTestSignals::_internal_add_signals(double value) {
  _impl_.signals_.Add(value);
}
inline void EgmTestSignals::add_signals(double value) {
  _internal_add_signals(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmTestSignals.signals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmTestSignals::_internal_signals() const {
  return _impl_.signals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmTestSignals::signals() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmTestSignals.signals)
  return _internal_signals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmTestSignals::_internal_mutable_signals() {
  return &_impl_.signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmTestSignals::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmTestSignals.signals)
  return _internal_mutable_signals();
}

// -------------------------------------------------------------------

// EgmMeasuredForce

// optional bool fcActive = 1;
inline bool EgmMeasuredForce::_internal_has_fcactive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmMeasuredForce::has_fcactive() const {
  return _internal_has_fcactive();
}
inline void EgmMeasuredForce::clear_fcactive() {
  _impl_.fcactive_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EgmMeasuredForce::_internal_fcactive() const {
  return _impl_.fcactive_;
}
inline bool EgmMeasuredForce::fcactive() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMeasuredForce.fcActive)
  return _internal_fcactive();
}
inline void EgmMeasuredForce::_internal_set_fcactive(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fcactive_ = value;
}
inline void EgmMeasuredForce::set_fcactive(bool value) {
  _internal_set_fcactive(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMeasuredForce.fcActive)
}

// repeated double force = 2;
inline int EgmMeasuredForce::_internal_force_size() const {
  return _impl_.force_.size();
}
inline int EgmMeasuredForce::force_size() const {
  return _internal_force_size();
}
inline void EgmMeasuredForce::clear_force() {
  _impl_.force_.Clear();
}
inline double EgmMeasuredForce::_internal_force(int index) const {
  return _impl_.force_.Get(index);
}
inline double EgmMeasuredForce::force(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMeasuredForce.force)
  return _internal_force(index);
}
inline void EgmMeasuredForce::set_force(int index, double value) {
  _impl_.force_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmMeasuredForce.force)
}
inline void EgmMeasuredForce::_internal_add_force(double value) {
  _impl_.force_.Add(value);
}
inline void EgmMeasuredForce::add_force(double value) {
  _internal_add_force(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmMeasuredForce.force)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmMeasuredForce::_internal_force() const {
  return _impl_.force_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmMeasuredForce::force() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmMeasuredForce.force)
  return _internal_force();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmMeasuredForce::_internal_mutable_force() {
  return &_impl_.force_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmMeasuredForce::mutable_force() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmMeasuredForce.force)
  return _internal_mutable_force();
}

// -------------------------------------------------------------------

// EgmCollisionInfo

// optional bool collsionTriggered = 1;
inline bool EgmCollisionInfo::_internal_has_collsiontriggered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmCollisionInfo::has_collsiontriggered() const {
  return _internal_has_collsiontriggered();
}
inline void EgmCollisionInfo::clear_collsiontriggered() {
  _impl_.collsiontriggered_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EgmCollisionInfo::_internal_collsiontriggered() const {
  return _impl_.collsiontriggered_;
}
inline bool EgmCollisionInfo::collsiontriggered() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCollisionInfo.collsionTriggered)
  return _internal_collsiontriggered();
}
inline void EgmCollisionInfo::_internal_set_collsiontriggered(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collsiontriggered_ = value;
}
inline void EgmCollisionInfo::set_collsiontriggered(bool value) {
  _internal_set_collsiontriggered(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCollisionInfo.collsionTriggered)
}

// repeated double collDetQuota = 2;
inline int EgmCollisionInfo::_internal_colldetquota_size() const {
  return _impl_.colldetquota_.size();
}
inline int EgmCollisionInfo::colldetquota_size() const {
  return _internal_colldetquota_size();
}
inline void EgmCollisionInfo::clear_colldetquota() {
  _impl_.colldetquota_.Clear();
}
inline double EgmCollisionInfo::_internal_colldetquota(int index) const {
  return _impl_.colldetquota_.Get(index);
}
inline double EgmCollisionInfo::colldetquota(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCollisionInfo.collDetQuota)
  return _internal_colldetquota(index);
}
inline void EgmCollisionInfo::set_colldetquota(int index, double value) {
  _impl_.colldetquota_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCollisionInfo.collDetQuota)
}
inline void EgmCollisionInfo::_internal_add_colldetquota(double value) {
  _impl_.colldetquota_.Add(value);
}
inline void EgmCollisionInfo::add_colldetquota(double value) {
  _internal_add_colldetquota(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmCollisionInfo.collDetQuota)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCollisionInfo::_internal_colldetquota() const {
  return _impl_.colldetquota_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmCollisionInfo::colldetquota() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmCollisionInfo.collDetQuota)
  return _internal_colldetquota();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCollisionInfo::_internal_mutable_colldetquota() {
  return &_impl_.colldetquota_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmCollisionInfo::mutable_colldetquota() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmCollisionInfo.collDetQuota)
  return _internal_mutable_colldetquota();
}

// -------------------------------------------------------------------

// EgmRAPIDdata

// optional bool digVal = 1;
inline bool EgmRAPIDdata::_internal_has_digval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EgmRAPIDdata::has_digval() const {
  return _internal_has_digval();
}
inline void EgmRAPIDdata::clear_digval() {
  _impl_.digval_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EgmRAPIDdata::_internal_digval() const {
  return _impl_.digval_;
}
inline bool EgmRAPIDdata::digval() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRAPIDdata.digVal)
  return _internal_digval();
}
inline void EgmRAPIDdata::_internal_set_digval(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.digval_ = value;
}
inline void EgmRAPIDdata::set_digval(bool value) {
  _internal_set_digval(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRAPIDdata.digVal)
}

// repeated double dnum = 2;
inline int EgmRAPIDdata::_internal_dnum_size() const {
  return _impl_.dnum_.size();
}
inline int EgmRAPIDdata::dnum_size() const {
  return _internal_dnum_size();
}
inline void EgmRAPIDdata::clear_dnum() {
  _impl_.dnum_.Clear();
}
inline double EgmRAPIDdata::_internal_dnum(int index) const {
  return _impl_.dnum_.Get(index);
}
inline double EgmRAPIDdata::dnum(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRAPIDdata.dnum)
  return _internal_dnum(index);
}
inline void EgmRAPIDdata::set_dnum(int index, double value) {
  _impl_.dnum_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRAPIDdata.dnum)
}
inline void EgmRAPIDdata::_internal_add_dnum(double value) {
  _impl_.dnum_.Add(value);
}
inline void EgmRAPIDdata::add_dnum(double value) {
  _internal_add_dnum(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmRAPIDdata.dnum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmRAPIDdata::_internal_dnum() const {
  return _impl_.dnum_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
EgmRAPIDdata::dnum() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmRAPIDdata.dnum)
  return _internal_dnum();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmRAPIDdata::_internal_mutable_dnum() {
  return &_impl_.dnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
EgmRAPIDdata::mutable_dnum() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmRAPIDdata.dnum)
  return _internal_mutable_dnum();
}

// -------------------------------------------------------------------

// EgmRobot

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmRobot::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool EgmRobot::has_header() const {
  return _internal_has_header();
}
inline void EgmRobot::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmRobot::_internal_header() const {
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmRobot::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.header)
  return _internal_header();
}
inline void EgmRobot::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.header)
}
inline ::abb::egm::EgmHeader* EgmRobot::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmHeader* EgmRobot::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmRobot::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmRobot::mutable_header() {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.header)
  return _msg;
}
inline void EgmRobot::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.header)
}

// optional .abb.egm.EgmFeedBack feedBack = 2;
inline bool EgmRobot::_internal_has_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feedback_ != nullptr);
  return value;
}
inline bool EgmRobot::has_feedback() const {
  return _internal_has_feedback();
}
inline void EgmRobot::clear_feedback() {
  if (_impl_.feedback_ != nullptr) _impl_.feedback_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::_internal_feedback() const {
  const ::abb::egm::EgmFeedBack* p = _impl_.feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmFeedBack&>(
      ::abb::egm::_EgmFeedBack_default_instance_);
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::feedback() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.feedBack)
  return _internal_feedback();
}
inline void EgmRobot::unsafe_arena_set_allocated_feedback(
    ::abb::egm::EgmFeedBack* feedback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feedback_);
  }
  _impl_.feedback_ = feedback;
  if (feedback) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.feedBack)
}
inline ::abb::egm::EgmFeedBack* EgmRobot::release_feedback() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.feedBack)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmFeedBack* temp = _impl_.feedback_;
  _impl_.feedback_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::_internal_mutable_feedback() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmFeedBack>(GetArenaForAllocation());
    _impl_.feedback_ = p;
  }
  return _impl_.feedback_;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::mutable_feedback() {
  ::abb::egm::EgmFeedBack* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.feedBack)
  return _msg;
}
inline void EgmRobot::set_allocated_feedback(::abb::egm::EgmFeedBack* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.feedBack)
}

// optional .abb.egm.EgmPlanned planned = 3;
inline bool EgmRobot::_internal_has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline bool EgmRobot::has_planned() const {
  return _internal_has_planned();
}
inline void EgmRobot::clear_planned() {
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmPlanned& EgmRobot::_internal_planned() const {
  const ::abb::egm::EgmPlanned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(
      ::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmRobot::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.planned)
  return _internal_planned();
}
inline void EgmRobot::unsafe_arena_set_allocated_planned(
    ::abb::egm::EgmPlanned* planned) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = planned;
  if (planned) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.planned)
}
inline ::abb::egm::EgmPlanned* EgmRobot::release_planned() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmRobot::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.planned)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmRobot::_internal_mutable_planned() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArenaForAllocation());
    _impl_.planned_ = p;
  }
  return _impl_.planned_;
}
inline ::abb::egm::EgmPlanned* EgmRobot::mutable_planned() {
  ::abb::egm::EgmPlanned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.planned)
  return _msg;
}
inline void EgmRobot::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.planned)
}

// optional .abb.egm.EgmMotorState motorState = 4;
inline bool EgmRobot::_internal_has_motorstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motorstate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_motorstate() const {
  return _internal_has_motorstate();
}
inline void EgmRobot::clear_motorstate() {
  if (_impl_.motorstate_ != nullptr) _impl_.motorstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmMotorState& EgmRobot::_internal_motorstate() const {
  const ::abb::egm::EgmMotorState* p = _impl_.motorstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMotorState&>(
      ::abb::egm::_EgmMotorState_default_instance_);
}
inline const ::abb::egm::EgmMotorState& EgmRobot::motorstate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.motorState)
  return _internal_motorstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_motorstate(
    ::abb::egm::EgmMotorState* motorstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.motorstate_);
  }
  _impl_.motorstate_ = motorstate;
  if (motorstate) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.motorState)
}
inline ::abb::egm::EgmMotorState* EgmRobot::release_motorstate() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* temp = _impl_.motorstate_;
  _impl_.motorstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmMotorState* EgmRobot::unsafe_arena_release_motorstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.motorState)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmMotorState* temp = _impl_.motorstate_;
  _impl_.motorstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMotorState* EgmRobot::_internal_mutable_motorstate() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.motorstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMotorState>(GetArenaForAllocation());
    _impl_.motorstate_ = p;
  }
  return _impl_.motorstate_;
}
inline ::abb::egm::EgmMotorState* EgmRobot::mutable_motorstate() {
  ::abb::egm::EgmMotorState* _msg = _internal_mutable_motorstate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.motorState)
  return _msg;
}
inline void EgmRobot::set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.motorstate_;
  }
  if (motorstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motorstate);
    if (message_arena != submessage_arena) {
      motorstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motorstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.motorstate_ = motorstate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.motorState)
}

// optional .abb.egm.EgmMCIState mciState = 5;
inline bool EgmRobot::_internal_has_mcistate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mcistate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_mcistate() const {
  return _internal_has_mcistate();
}
inline void EgmRobot::clear_mcistate() {
  if (_impl_.mcistate_ != nullptr) _impl_.mcistate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::abb::egm::EgmMCIState& EgmRobot::_internal_mcistate() const {
  const ::abb::egm::EgmMCIState* p = _impl_.mcistate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMCIState&>(
      ::abb::egm::_EgmMCIState_default_instance_);
}
inline const ::abb::egm::EgmMCIState& EgmRobot::mcistate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciState)
  return _internal_mcistate();
}
inline void EgmRobot::unsafe_arena_set_allocated_mcistate(
    ::abb::egm::EgmMCIState* mcistate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mcistate_);
  }
  _impl_.mcistate_ = mcistate;
  if (mcistate) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.mciState)
}
inline ::abb::egm::EgmMCIState* EgmRobot::release_mcistate() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* temp = _impl_.mcistate_;
  _impl_.mcistate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmMCIState* EgmRobot::unsafe_arena_release_mcistate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.mciState)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::abb::egm::EgmMCIState* temp = _impl_.mcistate_;
  _impl_.mcistate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMCIState* EgmRobot::_internal_mutable_mcistate() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.mcistate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMCIState>(GetArenaForAllocation());
    _impl_.mcistate_ = p;
  }
  return _impl_.mcistate_;
}
inline ::abb::egm::EgmMCIState* EgmRobot::mutable_mcistate() {
  ::abb::egm::EgmMCIState* _msg = _internal_mutable_mcistate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.mciState)
  return _msg;
}
inline void EgmRobot::set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mcistate_;
  }
  if (mcistate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mcistate);
    if (message_arena != submessage_arena) {
      mcistate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mcistate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mcistate_ = mcistate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.mciState)
}

// optional bool mciConvergenceMet = 6;
inline bool EgmRobot::_internal_has_mciconvergencemet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool EgmRobot::has_mciconvergencemet() const {
  return _internal_has_mciconvergencemet();
}
inline void EgmRobot::clear_mciconvergencemet() {
  _impl_.mciconvergencemet_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool EgmRobot::_internal_mciconvergencemet() const {
  return _impl_.mciconvergencemet_;
}
inline bool EgmRobot::mciconvergencemet() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciConvergenceMet)
  return _internal_mciconvergencemet();
}
inline void EgmRobot::_internal_set_mciconvergencemet(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.mciconvergencemet_ = value;
}
inline void EgmRobot::set_mciconvergencemet(bool value) {
  _internal_set_mciconvergencemet(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.mciConvergenceMet)
}

// optional .abb.egm.EgmTestSignals testSignals = 7;
inline bool EgmRobot::_internal_has_testsignals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.testsignals_ != nullptr);
  return value;
}
inline bool EgmRobot::has_testsignals() const {
  return _internal_has_testsignals();
}
inline void EgmRobot::clear_testsignals() {
  if (_impl_.testsignals_ != nullptr) _impl_.testsignals_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::_internal_testsignals() const {
  const ::abb::egm::EgmTestSignals* p = _impl_.testsignals_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmTestSignals&>(
      ::abb::egm::_EgmTestSignals_default_instance_);
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::testsignals() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.testSignals)
  return _internal_testsignals();
}
inline void EgmRobot::unsafe_arena_set_allocated_testsignals(
    ::abb::egm::EgmTestSignals* testsignals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testsignals_);
  }
  _impl_.testsignals_ = testsignals;
  if (testsignals) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.testSignals)
}
inline ::abb::egm::EgmTestSignals* EgmRobot::release_testsignals() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* temp = _impl_.testsignals_;
  _impl_.testsignals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::unsafe_arena_release_testsignals() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.testSignals)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::abb::egm::EgmTestSignals* temp = _impl_.testsignals_;
  _impl_.testsignals_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::_internal_mutable_testsignals() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.testsignals_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmTestSignals>(GetArenaForAllocation());
    _impl_.testsignals_ = p;
  }
  return _impl_.testsignals_;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::mutable_testsignals() {
  ::abb::egm::EgmTestSignals* _msg = _internal_mutable_testsignals();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.testSignals)
  return _msg;
}
inline void EgmRobot::set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testsignals_;
  }
  if (testsignals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testsignals);
    if (message_arena != submessage_arena) {
      testsignals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testsignals, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.testsignals_ = testsignals;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.testSignals)
}

// optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
inline bool EgmRobot::_internal_has_rapidexecstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rapidexecstate_ != nullptr);
  return value;
}
inline bool EgmRobot::has_rapidexecstate() const {
  return _internal_has_rapidexecstate();
}
inline void EgmRobot::clear_rapidexecstate() {
  if (_impl_.rapidexecstate_ != nullptr) _impl_.rapidexecstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::_internal_rapidexecstate() const {
  const ::abb::egm::EgmRapidCtrlExecState* p = _impl_.rapidexecstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmRapidCtrlExecState&>(
      ::abb::egm::_EgmRapidCtrlExecState_default_instance_);
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::rapidexecstate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.rapidExecState)
  return _internal_rapidexecstate();
}
inline void EgmRobot::unsafe_arena_set_allocated_rapidexecstate(
    ::abb::egm::EgmRapidCtrlExecState* rapidexecstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rapidexecstate_);
  }
  _impl_.rapidexecstate_ = rapidexecstate;
  if (rapidexecstate) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.rapidExecState)
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::release_rapidexecstate() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* temp = _impl_.rapidexecstate_;
  _impl_.rapidexecstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::unsafe_arena_release_rapidexecstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.rapidExecState)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::abb::egm::EgmRapidCtrlExecState* temp = _impl_.rapidexecstate_;
  _impl_.rapidexecstate_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::_internal_mutable_rapidexecstate() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.rapidexecstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmRapidCtrlExecState>(GetArenaForAllocation());
    _impl_.rapidexecstate_ = p;
  }
  return _impl_.rapidexecstate_;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::mutable_rapidexecstate() {
  ::abb::egm::EgmRapidCtrlExecState* _msg = _internal_mutable_rapidexecstate();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.rapidExecState)
  return _msg;
}
inline void EgmRobot::set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rapidexecstate_;
  }
  if (rapidexecstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rapidexecstate);
    if (message_arena != submessage_arena) {
      rapidexecstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rapidexecstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.rapidexecstate_ = rapidexecstate;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.rapidExecState)
}

// optional .abb.egm.EgmMeasuredForce measuredForce = 9;
inline bool EgmRobot::_internal_has_measuredforce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.measuredforce_ != nullptr);
  return value;
}
inline bool EgmRobot::has_measuredforce() const {
  return _internal_has_measuredforce();
}
inline void EgmRobot::clear_measuredforce() {
  if (_impl_.measuredforce_ != nullptr) _impl_.measuredforce_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::_internal_measuredforce() const {
  const ::abb::egm::EgmMeasuredForce* p = _impl_.measuredforce_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmMeasuredForce&>(
      ::abb::egm::_EgmMeasuredForce_default_instance_);
}
inline const ::abb::egm::EgmMeasuredForce& EgmRobot::measuredforce() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.measuredForce)
  return _internal_measuredforce();
}
inline void EgmRobot::unsafe_arena_set_allocated_measuredforce(
    ::abb::egm::EgmMeasuredForce* measuredforce) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.measuredforce_);
  }
  _impl_.measuredforce_ = measuredforce;
  if (measuredforce) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.measuredForce)
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::release_measuredforce() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* temp = _impl_.measuredforce_;
  _impl_.measuredforce_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::unsafe_arena_release_measuredforce() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.measuredForce)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::abb::egm::EgmMeasuredForce* temp = _impl_.measuredforce_;
  _impl_.measuredforce_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::_internal_mutable_measuredforce() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.measuredforce_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmMeasuredForce>(GetArenaForAllocation());
    _impl_.measuredforce_ = p;
  }
  return _impl_.measuredforce_;
}
inline ::abb::egm::EgmMeasuredForce* EgmRobot::mutable_measuredforce() {
  ::abb::egm::EgmMeasuredForce* _msg = _internal_mutable_measuredforce();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.measuredForce)
  return _msg;
}
inline void EgmRobot::set_allocated_measuredforce(::abb::egm::EgmMeasuredForce* measuredforce) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.measuredforce_;
  }
  if (measuredforce) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(measuredforce);
    if (message_arena != submessage_arena) {
      measuredforce = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measuredforce, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.measuredforce_ = measuredforce;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.measuredForce)
}

// optional double utilizationRate = 10;
inline bool EgmRobot::_internal_has_utilizationrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool EgmRobot::has_utilizationrate() const {
  return _internal_has_utilizationrate();
}
inline void EgmRobot::clear_utilizationrate() {
  _impl_.utilizationrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline double EgmRobot::_internal_utilizationrate() const {
  return _impl_.utilizationrate_;
}
inline double EgmRobot::utilizationrate() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.utilizationRate)
  return _internal_utilizationrate();
}
inline void EgmRobot::_internal_set_utilizationrate(double value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.utilizationrate_ = value;
}
inline void EgmRobot::set_utilizationrate(double value) {
  _internal_set_utilizationrate(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.utilizationRate)
}

// optional uint32 moveIndex = 11;
inline bool EgmRobot::_internal_has_moveindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool EgmRobot::has_moveindex() const {
  return _internal_has_moveindex();
}
inline void EgmRobot::clear_moveindex() {
  _impl_.moveindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t EgmRobot::_internal_moveindex() const {
  return _impl_.moveindex_;
}
inline uint32_t EgmRobot::moveindex() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.moveIndex)
  return _internal_moveindex();
}
inline void EgmRobot::_internal_set_moveindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.moveindex_ = value;
}
inline void EgmRobot::set_moveindex(uint32_t value) {
  _internal_set_moveindex(value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.moveIndex)
}

// optional .abb.egm.EgmCollisionInfo CollisionInfo = 12;
inline bool EgmRobot::_internal_has_collisioninfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.collisioninfo_ != nullptr);
  return value;
}
inline bool EgmRobot::has_collisioninfo() const {
  return _internal_has_collisioninfo();
}
inline void EgmRobot::clear_collisioninfo() {
  if (_impl_.collisioninfo_ != nullptr) _impl_.collisioninfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::abb::egm::EgmCollisionInfo& EgmRobot::_internal_collisioninfo() const {
  const ::abb::egm::EgmCollisionInfo* p = _impl_.collisioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmCollisionInfo&>(
      ::abb::egm::_EgmCollisionInfo_default_instance_);
}
inline const ::abb::egm::EgmCollisionInfo& EgmRobot::collisioninfo() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.CollisionInfo)
  return _internal_collisioninfo();
}
inline void EgmRobot::unsafe_arena_set_allocated_collisioninfo(
    ::abb::egm::EgmCollisionInfo* collisioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collisioninfo_);
  }
  _impl_.collisioninfo_ = collisioninfo;
  if (collisioninfo) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.CollisionInfo)
}
inline ::abb::egm::EgmCollisionInfo* EgmRobot::release_collisioninfo() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::abb::egm::EgmCollisionInfo* temp = _impl_.collisioninfo_;
  _impl_.collisioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmCollisionInfo* EgmRobot::unsafe_arena_release_collisioninfo() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.CollisionInfo)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::abb::egm::EgmCollisionInfo* temp = _impl_.collisioninfo_;
  _impl_.collisioninfo_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmCollisionInfo* EgmRobot::_internal_mutable_collisioninfo() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.collisioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmCollisionInfo>(GetArenaForAllocation());
    _impl_.collisioninfo_ = p;
  }
  return _impl_.collisioninfo_;
}
inline ::abb::egm::EgmCollisionInfo* EgmRobot::mutable_collisioninfo() {
  ::abb::egm::EgmCollisionInfo* _msg = _internal_mutable_collisioninfo();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.CollisionInfo)
  return _msg;
}
inline void EgmRobot::set_allocated_collisioninfo(::abb::egm::EgmCollisionInfo* collisioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.collisioninfo_;
  }
  if (collisioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collisioninfo);
    if (message_arena != submessage_arena) {
      collisioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collisioninfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.collisioninfo_ = collisioninfo;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.CollisionInfo)
}

// optional .abb.egm.EgmRAPIDdata RAPIDfromRobot = 13;
inline bool EgmRobot::_internal_has_rapidfromrobot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rapidfromrobot_ != nullptr);
  return value;
}
inline bool EgmRobot::has_rapidfromrobot() const {
  return _internal_has_rapidfromrobot();
}
inline void EgmRobot::clear_rapidfromrobot() {
  if (_impl_.rapidfromrobot_ != nullptr) _impl_.rapidfromrobot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::abb::egm::EgmRAPIDdata& EgmRobot::_internal_rapidfromrobot() const {
  const ::abb::egm::EgmRAPIDdata* p = _impl_.rapidfromrobot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmRAPIDdata&>(
      ::abb::egm::_EgmRAPIDdata_default_instance_);
}
inline const ::abb::egm::EgmRAPIDdata& EgmRobot::rapidfromrobot() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.RAPIDfromRobot)
  return _internal_rapidfromrobot();
}
inline void EgmRobot::unsafe_arena_set_allocated_rapidfromrobot(
    ::abb::egm::EgmRAPIDdata* rapidfromrobot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rapidfromrobot_);
  }
  _impl_.rapidfromrobot_ = rapidfromrobot;
  if (rapidfromrobot) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmRobot.RAPIDfromRobot)
}
inline ::abb::egm::EgmRAPIDdata* EgmRobot::release_rapidfromrobot() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::abb::egm::EgmRAPIDdata* temp = _impl_.rapidfromrobot_;
  _impl_.rapidfromrobot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmRAPIDdata* EgmRobot::unsafe_arena_release_rapidfromrobot() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.RAPIDfromRobot)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::abb::egm::EgmRAPIDdata* temp = _impl_.rapidfromrobot_;
  _impl_.rapidfromrobot_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmRAPIDdata* EgmRobot::_internal_mutable_rapidfromrobot() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.rapidfromrobot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmRAPIDdata>(GetArenaForAllocation());
    _impl_.rapidfromrobot_ = p;
  }
  return _impl_.rapidfromrobot_;
}
inline ::abb::egm::EgmRAPIDdata* EgmRobot::mutable_rapidfromrobot() {
  ::abb::egm::EgmRAPIDdata* _msg = _internal_mutable_rapidfromrobot();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.RAPIDfromRobot)
  return _msg;
}
inline void EgmRobot::set_allocated_rapidfromrobot(::abb::egm::EgmRAPIDdata* rapidfromrobot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rapidfromrobot_;
  }
  if (rapidfromrobot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rapidfromrobot);
    if (message_arena != submessage_arena) {
      rapidfromrobot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rapidfromrobot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.rapidfromrobot_ = rapidfromrobot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.RAPIDfromRobot)
}

// -------------------------------------------------------------------

// EgmSensor

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensor::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool EgmSensor::has_header() const {
  return _internal_has_header();
}
inline void EgmSensor::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensor::_internal_header() const {
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensor::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.header)
  return _internal_header();
}
inline void EgmSensor::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.header)
}
inline ::abb::egm::EgmHeader* EgmSensor::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensor::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensor::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmSensor::mutable_header() {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.header)
  return _msg;
}
inline void EgmSensor::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.header)
}

// optional .abb.egm.EgmPlanned planned = 2;
inline bool EgmSensor::_internal_has_planned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.planned_ != nullptr);
  return value;
}
inline bool EgmSensor::has_planned() const {
  return _internal_has_planned();
}
inline void EgmSensor::clear_planned() {
  if (_impl_.planned_ != nullptr) _impl_.planned_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPlanned& EgmSensor::_internal_planned() const {
  const ::abb::egm::EgmPlanned* p = _impl_.planned_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPlanned&>(
      ::abb::egm::_EgmPlanned_default_instance_);
}
inline const ::abb::egm::EgmPlanned& EgmSensor::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.planned)
  return _internal_planned();
}
inline void EgmSensor::unsafe_arena_set_allocated_planned(
    ::abb::egm::EgmPlanned* planned) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.planned_);
  }
  _impl_.planned_ = planned;
  if (planned) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.planned)
}
inline ::abb::egm::EgmPlanned* EgmSensor::release_planned() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmSensor::unsafe_arena_release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.planned)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPlanned* temp = _impl_.planned_;
  _impl_.planned_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPlanned* EgmSensor::_internal_mutable_planned() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.planned_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPlanned>(GetArenaForAllocation());
    _impl_.planned_ = p;
  }
  return _impl_.planned_;
}
inline ::abb::egm::EgmPlanned* EgmSensor::mutable_planned() {
  ::abb::egm::EgmPlanned* _msg = _internal_mutable_planned();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.planned)
  return _msg;
}
inline void EgmSensor::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.planned_;
  }
  if (planned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(planned);
    if (message_arena != submessage_arena) {
      planned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planned, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.planned_ = planned;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.planned)
}

// optional .abb.egm.EgmSpeedRef speedRef = 3;
inline bool EgmSensor::_internal_has_speedref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speedref_ != nullptr);
  return value;
}
inline bool EgmSensor::has_speedref() const {
  return _internal_has_speedref();
}
inline void EgmSensor::clear_speedref() {
  if (_impl_.speedref_ != nullptr) _impl_.speedref_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::_internal_speedref() const {
  const ::abb::egm::EgmSpeedRef* p = _impl_.speedref_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmSpeedRef&>(
      ::abb::egm::_EgmSpeedRef_default_instance_);
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::speedref() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.speedRef)
  return _internal_speedref();
}
inline void EgmSensor::unsafe_arena_set_allocated_speedref(
    ::abb::egm::EgmSpeedRef* speedref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.speedref_);
  }
  _impl_.speedref_ = speedref;
  if (speedref) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.speedRef)
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::release_speedref() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* temp = _impl_.speedref_;
  _impl_.speedref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::unsafe_arena_release_speedref() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.speedRef)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::abb::egm::EgmSpeedRef* temp = _impl_.speedref_;
  _impl_.speedref_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::_internal_mutable_speedref() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.speedref_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmSpeedRef>(GetArenaForAllocation());
    _impl_.speedref_ = p;
  }
  return _impl_.speedref_;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::mutable_speedref() {
  ::abb::egm::EgmSpeedRef* _msg = _internal_mutable_speedref();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.speedRef)
  return _msg;
}
inline void EgmSensor::set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.speedref_;
  }
  if (speedref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(speedref);
    if (message_arena != submessage_arena) {
      speedref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speedref, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.speedref_ = speedref;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.speedRef)
}

// optional .abb.egm.EgmRAPIDdata RAPIDtoRobot = 4;
inline bool EgmSensor::_internal_has_rapidtorobot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rapidtorobot_ != nullptr);
  return value;
}
inline bool EgmSensor::has_rapidtorobot() const {
  return _internal_has_rapidtorobot();
}
inline void EgmSensor::clear_rapidtorobot() {
  if (_impl_.rapidtorobot_ != nullptr) _impl_.rapidtorobot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::abb::egm::EgmRAPIDdata& EgmSensor::_internal_rapidtorobot() const {
  const ::abb::egm::EgmRAPIDdata* p = _impl_.rapidtorobot_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmRAPIDdata&>(
      ::abb::egm::_EgmRAPIDdata_default_instance_);
}
inline const ::abb::egm::EgmRAPIDdata& EgmSensor::rapidtorobot() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.RAPIDtoRobot)
  return _internal_rapidtorobot();
}
inline void EgmSensor::unsafe_arena_set_allocated_rapidtorobot(
    ::abb::egm::EgmRAPIDdata* rapidtorobot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rapidtorobot_);
  }
  _impl_.rapidtorobot_ = rapidtorobot;
  if (rapidtorobot) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensor.RAPIDtoRobot)
}
inline ::abb::egm::EgmRAPIDdata* EgmSensor::release_rapidtorobot() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmRAPIDdata* temp = _impl_.rapidtorobot_;
  _impl_.rapidtorobot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmRAPIDdata* EgmSensor::unsafe_arena_release_rapidtorobot() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.RAPIDtoRobot)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::abb::egm::EgmRAPIDdata* temp = _impl_.rapidtorobot_;
  _impl_.rapidtorobot_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmRAPIDdata* EgmSensor::_internal_mutable_rapidtorobot() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rapidtorobot_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmRAPIDdata>(GetArenaForAllocation());
    _impl_.rapidtorobot_ = p;
  }
  return _impl_.rapidtorobot_;
}
inline ::abb::egm::EgmRAPIDdata* EgmSensor::mutable_rapidtorobot() {
  ::abb::egm::EgmRAPIDdata* _msg = _internal_mutable_rapidtorobot();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.RAPIDtoRobot)
  return _msg;
}
inline void EgmSensor::set_allocated_rapidtorobot(::abb::egm::EgmRAPIDdata* rapidtorobot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rapidtorobot_;
  }
  if (rapidtorobot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rapidtorobot);
    if (message_arena != submessage_arena) {
      rapidtorobot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rapidtorobot, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rapidtorobot_ = rapidtorobot;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.RAPIDtoRobot)
}

// -------------------------------------------------------------------

// EgmSensorPathCorr

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensorPathCorr::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool EgmSensorPathCorr::has_header() const {
  return _internal_has_header();
}
inline void EgmSensorPathCorr::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::_internal_header() const {
  const ::abb::egm::EgmHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmHeader&>(
      ::abb::egm::_EgmHeader_default_instance_);
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.header)
  return _internal_header();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_header(
    ::abb::egm::EgmHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.header)
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abb::egm::EgmHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::mutable_header() {
  ::abb::egm::EgmHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.header)
  return _msg;
}
inline void EgmSensorPathCorr::set_allocated_header(::abb::egm::EgmHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.header)
}

// optional .abb.egm.EgmPathCorr pathCorr = 2;
inline bool EgmSensorPathCorr::_internal_has_pathcorr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathcorr_ != nullptr);
  return value;
}
inline bool EgmSensorPathCorr::has_pathcorr() const {
  return _internal_has_pathcorr();
}
inline void EgmSensorPathCorr::clear_pathcorr() {
  if (_impl_.pathcorr_ != nullptr) _impl_.pathcorr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::_internal_pathcorr() const {
  const ::abb::egm::EgmPathCorr* p = _impl_.pathcorr_;
  return p != nullptr ? *p : reinterpret_cast<const ::abb::egm::EgmPathCorr&>(
      ::abb::egm::_EgmPathCorr_default_instance_);
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::pathcorr() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.pathCorr)
  return _internal_pathcorr();
}
inline void EgmSensorPathCorr::unsafe_arena_set_allocated_pathcorr(
    ::abb::egm::EgmPathCorr* pathcorr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathcorr_);
  }
  _impl_.pathcorr_ = pathcorr;
  if (pathcorr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::release_pathcorr() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* temp = _impl_.pathcorr_;
  _impl_.pathcorr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::unsafe_arena_release_pathcorr() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.pathCorr)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::abb::egm::EgmPathCorr* temp = _impl_.pathcorr_;
  _impl_.pathcorr_ = nullptr;
  return temp;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::_internal_mutable_pathcorr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pathcorr_ == nullptr) {
    auto* p = CreateMaybeMessage<::abb::egm::EgmPathCorr>(GetArenaForAllocation());
    _impl_.pathcorr_ = p;
  }
  return _impl_.pathcorr_;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::mutable_pathcorr() {
  ::abb::egm::EgmPathCorr* _msg = _internal_mutable_pathcorr();
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.pathCorr)
  return _msg;
}
inline void EgmSensorPathCorr::set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pathcorr_;
  }
  if (pathcorr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pathcorr);
    if (message_arena != submessage_arena) {
      pathcorr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathcorr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pathcorr_ = pathcorr;
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace egm
}  // namespace abb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abb::egm::EgmHeader_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmHeader_MessageType>() {
  return ::abb::egm::EgmHeader_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMotorState_MotorStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMotorState_MotorStateType>() {
  return ::abb::egm::EgmMotorState_MotorStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMCIState_MCIStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMCIState_MCIStateType>() {
  return ::abb::egm::EgmMCIState_MCIStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>() {
  return ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_egm_2eproto

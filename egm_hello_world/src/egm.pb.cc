// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#include "egm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace abb {
namespace egm {
PROTOBUF_CONSTEXPR EgmHeader::EgmHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seqno_)*/0u
  , /*decltype(_impl_.tm_)*/0u
  , /*decltype(_impl_.mtype_)*/0} {}
struct EgmHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmHeaderDefaultTypeInternal() {}
  union {
    EgmHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmHeaderDefaultTypeInternal _EgmHeader_default_instance_;
PROTOBUF_CONSTEXPR EgmCartesian::EgmCartesian(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct EgmCartesianDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmCartesianDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmCartesianDefaultTypeInternal() {}
  union {
    EgmCartesian _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmCartesianDefaultTypeInternal _EgmCartesian_default_instance_;
PROTOBUF_CONSTEXPR EgmQuaternion::EgmQuaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.u0_)*/0
  , /*decltype(_impl_.u1_)*/0
  , /*decltype(_impl_.u2_)*/0
  , /*decltype(_impl_.u3_)*/0} {}
struct EgmQuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmQuaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmQuaternionDefaultTypeInternal() {}
  union {
    EgmQuaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmQuaternionDefaultTypeInternal _EgmQuaternion_default_instance_;
PROTOBUF_CONSTEXPR EgmEuler::EgmEuler(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct EgmEulerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmEulerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmEulerDefaultTypeInternal() {}
  union {
    EgmEuler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmEulerDefaultTypeInternal _EgmEuler_default_instance_;
PROTOBUF_CONSTEXPR EgmClock::EgmClock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sec_)*/uint64_t{0u}
  , /*decltype(_impl_.usec_)*/uint64_t{0u}} {}
struct EgmClockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmClockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmClockDefaultTypeInternal() {}
  union {
    EgmClock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmClockDefaultTypeInternal _EgmClock_default_instance_;
PROTOBUF_CONSTEXPR EgmPose::EgmPose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.orient_)*/nullptr
  , /*decltype(_impl_.euler_)*/nullptr} {}
struct EgmPoseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmPoseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmPoseDefaultTypeInternal() {}
  union {
    EgmPose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmPoseDefaultTypeInternal _EgmPose_default_instance_;
PROTOBUF_CONSTEXPR EgmCartesianSpeed::EgmCartesianSpeed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EgmCartesianSpeedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmCartesianSpeedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmCartesianSpeedDefaultTypeInternal() {}
  union {
    EgmCartesianSpeed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmCartesianSpeedDefaultTypeInternal _EgmCartesianSpeed_default_instance_;
PROTOBUF_CONSTEXPR EgmJoints::EgmJoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.joints_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EgmJointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmJointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmJointsDefaultTypeInternal() {}
  union {
    EgmJoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmJointsDefaultTypeInternal _EgmJoints_default_instance_;
PROTOBUF_CONSTEXPR EgmExternalJoints::EgmExternalJoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.joints_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EgmExternalJointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmExternalJointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmExternalJointsDefaultTypeInternal() {}
  union {
    EgmExternalJoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmExternalJointsDefaultTypeInternal _EgmExternalJoints_default_instance_;
PROTOBUF_CONSTEXPR EgmPlanned::EgmPlanned(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.joints_)*/nullptr
  , /*decltype(_impl_.cartesian_)*/nullptr
  , /*decltype(_impl_.externaljoints_)*/nullptr
  , /*decltype(_impl_.time_)*/nullptr} {}
struct EgmPlannedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmPlannedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmPlannedDefaultTypeInternal() {}
  union {
    EgmPlanned _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmPlannedDefaultTypeInternal _EgmPlanned_default_instance_;
PROTOBUF_CONSTEXPR EgmSpeedRef::EgmSpeedRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.joints_)*/nullptr
  , /*decltype(_impl_.cartesians_)*/nullptr
  , /*decltype(_impl_.externaljoints_)*/nullptr} {}
struct EgmSpeedRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmSpeedRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmSpeedRefDefaultTypeInternal() {}
  union {
    EgmSpeedRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmSpeedRefDefaultTypeInternal _EgmSpeedRef_default_instance_;
PROTOBUF_CONSTEXPR EgmPathCorr::EgmPathCorr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.age_)*/0u} {}
struct EgmPathCorrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmPathCorrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmPathCorrDefaultTypeInternal() {}
  union {
    EgmPathCorr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmPathCorrDefaultTypeInternal _EgmPathCorr_default_instance_;
PROTOBUF_CONSTEXPR EgmFeedBack::EgmFeedBack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.joints_)*/nullptr
  , /*decltype(_impl_.cartesian_)*/nullptr
  , /*decltype(_impl_.externaljoints_)*/nullptr
  , /*decltype(_impl_.time_)*/nullptr} {}
struct EgmFeedBackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmFeedBackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmFeedBackDefaultTypeInternal() {}
  union {
    EgmFeedBack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmFeedBackDefaultTypeInternal _EgmFeedBack_default_instance_;
PROTOBUF_CONSTEXPR EgmMotorState::EgmMotorState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0} {}
struct EgmMotorStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmMotorStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmMotorStateDefaultTypeInternal() {}
  union {
    EgmMotorState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmMotorStateDefaultTypeInternal _EgmMotorState_default_instance_;
PROTOBUF_CONSTEXPR EgmMCIState::EgmMCIState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0} {}
struct EgmMCIStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmMCIStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmMCIStateDefaultTypeInternal() {}
  union {
    EgmMCIState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmMCIStateDefaultTypeInternal _EgmMCIState_default_instance_;
PROTOBUF_CONSTEXPR EgmRapidCtrlExecState::EgmRapidCtrlExecState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0} {}
struct EgmRapidCtrlExecStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmRapidCtrlExecStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmRapidCtrlExecStateDefaultTypeInternal() {}
  union {
    EgmRapidCtrlExecState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmRapidCtrlExecStateDefaultTypeInternal _EgmRapidCtrlExecState_default_instance_;
PROTOBUF_CONSTEXPR EgmTestSignals::EgmTestSignals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signals_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EgmTestSignalsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmTestSignalsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmTestSignalsDefaultTypeInternal() {}
  union {
    EgmTestSignals _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmTestSignalsDefaultTypeInternal _EgmTestSignals_default_instance_;
PROTOBUF_CONSTEXPR EgmMeasuredForce::EgmMeasuredForce(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.force_)*/{}
  , /*decltype(_impl_.fcactive_)*/false} {}
struct EgmMeasuredForceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmMeasuredForceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmMeasuredForceDefaultTypeInternal() {}
  union {
    EgmMeasuredForce _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmMeasuredForceDefaultTypeInternal _EgmMeasuredForce_default_instance_;
PROTOBUF_CONSTEXPR EgmCollisionInfo::EgmCollisionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.colldetquota_)*/{}
  , /*decltype(_impl_.collsiontriggered_)*/false} {}
struct EgmCollisionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmCollisionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmCollisionInfoDefaultTypeInternal() {}
  union {
    EgmCollisionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmCollisionInfoDefaultTypeInternal _EgmCollisionInfo_default_instance_;
PROTOBUF_CONSTEXPR EgmRAPIDdata::EgmRAPIDdata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dnum_)*/{}
  , /*decltype(_impl_.digval_)*/false} {}
struct EgmRAPIDdataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmRAPIDdataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmRAPIDdataDefaultTypeInternal() {}
  union {
    EgmRAPIDdata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmRAPIDdataDefaultTypeInternal _EgmRAPIDdata_default_instance_;
PROTOBUF_CONSTEXPR EgmRobot::EgmRobot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.feedback_)*/nullptr
  , /*decltype(_impl_.planned_)*/nullptr
  , /*decltype(_impl_.motorstate_)*/nullptr
  , /*decltype(_impl_.mcistate_)*/nullptr
  , /*decltype(_impl_.testsignals_)*/nullptr
  , /*decltype(_impl_.rapidexecstate_)*/nullptr
  , /*decltype(_impl_.measuredforce_)*/nullptr
  , /*decltype(_impl_.collisioninfo_)*/nullptr
  , /*decltype(_impl_.rapidfromrobot_)*/nullptr
  , /*decltype(_impl_.mciconvergencemet_)*/false
  , /*decltype(_impl_.moveindex_)*/0u
  , /*decltype(_impl_.utilizationrate_)*/0} {}
struct EgmRobotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmRobotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmRobotDefaultTypeInternal() {}
  union {
    EgmRobot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmRobotDefaultTypeInternal _EgmRobot_default_instance_;
PROTOBUF_CONSTEXPR EgmSensor::EgmSensor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.planned_)*/nullptr
  , /*decltype(_impl_.speedref_)*/nullptr
  , /*decltype(_impl_.rapidtorobot_)*/nullptr} {}
struct EgmSensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmSensorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmSensorDefaultTypeInternal() {}
  union {
    EgmSensor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmSensorDefaultTypeInternal _EgmSensor_default_instance_;
PROTOBUF_CONSTEXPR EgmSensorPathCorr::EgmSensorPathCorr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.pathcorr_)*/nullptr} {}
struct EgmSensorPathCorrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EgmSensorPathCorrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EgmSensorPathCorrDefaultTypeInternal() {}
  union {
    EgmSensorPathCorr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EgmSensorPathCorrDefaultTypeInternal _EgmSensorPathCorr_default_instance_;
}  // namespace egm
}  // namespace abb
static ::_pb::Metadata file_level_metadata_egm_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_egm_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_egm_2eproto = nullptr;

const uint32_t TableStruct_egm_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _impl_.seqno_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _impl_.tm_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmHeader, _impl_.mtype_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesian, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _impl_.u0_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _impl_.u1_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _impl_.u2_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmQuaternion, _impl_.u3_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmEuler, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _impl_.sec_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmClock, _impl_.usec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _impl_.orient_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPose, _impl_.euler_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmJoints, _impl_.joints_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmExternalJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmExternalJoints, _impl_.joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _impl_.joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _impl_.cartesian_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _impl_.externaljoints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPlanned, _impl_.time_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _impl_.joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _impl_.cartesians_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _impl_.externaljoints_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmPathCorr, _impl_.age_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _impl_.joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _impl_.cartesian_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _impl_.externaljoints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmFeedBack, _impl_.time_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMotorState, _impl_.state_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMCIState, _impl_.state_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _impl_.state_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmTestSignals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmTestSignals, _impl_.signals_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, _impl_.fcactive_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmMeasuredForce, _impl_.force_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCollisionInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCollisionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCollisionInfo, _impl_.collsiontriggered_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmCollisionInfo, _impl_.colldetquota_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRAPIDdata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRAPIDdata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRAPIDdata, _impl_.digval_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRAPIDdata, _impl_.dnum_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.feedback_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.planned_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.motorstate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.mcistate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.mciconvergencemet_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.testsignals_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.rapidexecstate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.measuredforce_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.utilizationrate_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.moveindex_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.collisioninfo_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmRobot, _impl_.rapidfromrobot_),
  0,
  1,
  2,
  3,
  4,
  10,
  5,
  6,
  7,
  12,
  11,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _impl_.planned_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _impl_.speedref_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensor, _impl_.rapidtorobot_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _impl_.pathcorr_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::abb::egm::EgmHeader)},
  { 12, 21, -1, sizeof(::abb::egm::EgmCartesian)},
  { 24, 34, -1, sizeof(::abb::egm::EgmQuaternion)},
  { 38, 47, -1, sizeof(::abb::egm::EgmEuler)},
  { 50, 58, -1, sizeof(::abb::egm::EgmClock)},
  { 60, 69, -1, sizeof(::abb::egm::EgmPose)},
  { 72, -1, -1, sizeof(::abb::egm::EgmCartesianSpeed)},
  { 79, -1, -1, sizeof(::abb::egm::EgmJoints)},
  { 86, -1, -1, sizeof(::abb::egm::EgmExternalJoints)},
  { 93, 103, -1, sizeof(::abb::egm::EgmPlanned)},
  { 107, 116, -1, sizeof(::abb::egm::EgmSpeedRef)},
  { 119, 127, -1, sizeof(::abb::egm::EgmPathCorr)},
  { 129, 139, -1, sizeof(::abb::egm::EgmFeedBack)},
  { 143, 150, -1, sizeof(::abb::egm::EgmMotorState)},
  { 151, 158, -1, sizeof(::abb::egm::EgmMCIState)},
  { 159, 166, -1, sizeof(::abb::egm::EgmRapidCtrlExecState)},
  { 167, -1, -1, sizeof(::abb::egm::EgmTestSignals)},
  { 174, 182, -1, sizeof(::abb::egm::EgmMeasuredForce)},
  { 184, 192, -1, sizeof(::abb::egm::EgmCollisionInfo)},
  { 194, 202, -1, sizeof(::abb::egm::EgmRAPIDdata)},
  { 204, 223, -1, sizeof(::abb::egm::EgmRobot)},
  { 236, 246, -1, sizeof(::abb::egm::EgmSensor)},
  { 250, 258, -1, sizeof(::abb::egm::EgmSensorPathCorr)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::abb::egm::_EgmHeader_default_instance_._instance,
  &::abb::egm::_EgmCartesian_default_instance_._instance,
  &::abb::egm::_EgmQuaternion_default_instance_._instance,
  &::abb::egm::_EgmEuler_default_instance_._instance,
  &::abb::egm::_EgmClock_default_instance_._instance,
  &::abb::egm::_EgmPose_default_instance_._instance,
  &::abb::egm::_EgmCartesianSpeed_default_instance_._instance,
  &::abb::egm::_EgmJoints_default_instance_._instance,
  &::abb::egm::_EgmExternalJoints_default_instance_._instance,
  &::abb::egm::_EgmPlanned_default_instance_._instance,
  &::abb::egm::_EgmSpeedRef_default_instance_._instance,
  &::abb::egm::_EgmPathCorr_default_instance_._instance,
  &::abb::egm::_EgmFeedBack_default_instance_._instance,
  &::abb::egm::_EgmMotorState_default_instance_._instance,
  &::abb::egm::_EgmMCIState_default_instance_._instance,
  &::abb::egm::_EgmRapidCtrlExecState_default_instance_._instance,
  &::abb::egm::_EgmTestSignals_default_instance_._instance,
  &::abb::egm::_EgmMeasuredForce_default_instance_._instance,
  &::abb::egm::_EgmCollisionInfo_default_instance_._instance,
  &::abb::egm::_EgmRAPIDdata_default_instance_._instance,
  &::abb::egm::_EgmRobot_default_instance_._instance,
  &::abb::egm::_EgmSensor_default_instance_._instance,
  &::abb::egm::_EgmSensorPathCorr_default_instance_._instance,
};

const char descriptor_table_protodef_egm_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\tegm.proto\022\007abb.egm\"\353\001\n\tEgmHeader\022\r\n\005se"
  "qno\030\001 \001(\r\022\n\n\002tm\030\002 \001(\r\022@\n\005mtype\030\003 \001(\0162\036.a"
  "bb.egm.EgmHeader.MessageType:\021MSGTYPE_UN"
  "DEFINED\"\200\001\n\013MessageType\022\025\n\021MSGTYPE_UNDEF"
  "INED\020\000\022\023\n\017MSGTYPE_COMMAND\020\001\022\020\n\014MSGTYPE_D"
  "ATA\020\002\022\026\n\022MSGTYPE_CORRECTION\020\003\022\033\n\027MSGTYPE"
  "_PATH_CORRECTION\020\004\"/\n\014EgmCartesian\022\t\n\001x\030"
  "\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\?\n\rEgmQuater"
  "nion\022\n\n\002u0\030\001 \002(\001\022\n\n\002u1\030\002 \002(\001\022\n\n\002u2\030\003 \002(\001"
  "\022\n\n\002u3\030\004 \002(\001\"+\n\010EgmEuler\022\t\n\001x\030\001 \002(\001\022\t\n\001y"
  "\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"%\n\010EgmClock\022\013\n\003sec\030\001 \002"
  "(\004\022\014\n\004usec\030\002 \002(\004\"w\n\007EgmPose\022\"\n\003pos\030\001 \001(\013"
  "2\025.abb.egm.EgmCartesian\022&\n\006orient\030\002 \001(\0132"
  "\026.abb.egm.EgmQuaternion\022 \n\005euler\030\003 \001(\0132\021"
  ".abb.egm.EgmEuler\"\"\n\021EgmCartesianSpeed\022\r"
  "\n\005value\030\001 \003(\001\"\033\n\tEgmJoints\022\016\n\006joints\030\001 \003"
  "(\001\"#\n\021EgmExternalJoints\022\016\n\006joints\030\001 \003(\001\""
  "\242\001\n\nEgmPlanned\022\"\n\006joints\030\001 \001(\0132\022.abb.egm"
  ".EgmJoints\022#\n\tcartesian\030\002 \001(\0132\020.abb.egm."
  "EgmPose\022*\n\016externalJoints\030\003 \001(\0132\022.abb.eg"
  "m.EgmJoints\022\037\n\004time\030\004 \001(\0132\021.abb.egm.EgmC"
  "lock\"\215\001\n\013EgmSpeedRef\022\"\n\006joints\030\001 \001(\0132\022.a"
  "bb.egm.EgmJoints\022.\n\ncartesians\030\002 \001(\0132\032.a"
  "bb.egm.EgmCartesianSpeed\022*\n\016externalJoin"
  "ts\030\003 \001(\0132\022.abb.egm.EgmJoints\">\n\013EgmPathC"
  "orr\022\"\n\003pos\030\001 \002(\0132\025.abb.egm.EgmCartesian\022"
  "\013\n\003age\030\002 \002(\r\"\243\001\n\013EgmFeedBack\022\"\n\006joints\030\001"
  " \001(\0132\022.abb.egm.EgmJoints\022#\n\tcartesian\030\002 "
  "\001(\0132\020.abb.egm.EgmPose\022*\n\016externalJoints\030"
  "\003 \001(\0132\022.abb.egm.EgmJoints\022\037\n\004time\030\004 \001(\0132"
  "\021.abb.egm.EgmClock\"\214\001\n\rEgmMotorState\0224\n\005"
  "state\030\001 \002(\0162%.abb.egm.EgmMotorState.Moto"
  "rStateType\"E\n\016MotorStateType\022\024\n\020MOTORS_U"
  "NDEFINED\020\000\022\r\n\tMOTORS_ON\020\001\022\016\n\nMOTORS_OFF\020"
  "\002\"\242\001\n\013EgmMCIState\022\?\n\005state\030\001 \002(\0162!.abb.e"
  "gm.EgmMCIState.MCIStateType:\rMCI_UNDEFIN"
  "ED\"R\n\014MCIStateType\022\021\n\rMCI_UNDEFINED\020\000\022\r\n"
  "\tMCI_ERROR\020\001\022\017\n\013MCI_STOPPED\020\002\022\017\n\013MCI_RUN"
  "NING\020\003\"\303\001\n\025EgmRapidCtrlExecState\022U\n\005stat"
  "e\030\001 \002(\01625.abb.egm.EgmRapidCtrlExecState."
  "RapidCtrlExecStateType:\017RAPID_UNDEFINED\""
  "S\n\026RapidCtrlExecStateType\022\023\n\017RAPID_UNDEF"
  "INED\020\000\022\021\n\rRAPID_STOPPED\020\001\022\021\n\rRAPID_RUNNI"
  "NG\020\002\"!\n\016EgmTestSignals\022\017\n\007signals\030\001 \003(\001\""
  "3\n\020EgmMeasuredForce\022\020\n\010fcActive\030\001 \001(\010\022\r\n"
  "\005force\030\002 \003(\001\"C\n\020EgmCollisionInfo\022\031\n\021coll"
  "sionTriggered\030\001 \001(\010\022\024\n\014collDetQuota\030\002 \003("
  "\001\",\n\014EgmRAPIDdata\022\016\n\006digVal\030\001 \001(\010\022\014\n\004dnu"
  "m\030\002 \003(\001\"\220\004\n\010EgmRobot\022\"\n\006header\030\001 \001(\0132\022.a"
  "bb.egm.EgmHeader\022&\n\010feedBack\030\002 \001(\0132\024.abb"
  ".egm.EgmFeedBack\022$\n\007planned\030\003 \001(\0132\023.abb."
  "egm.EgmPlanned\022*\n\nmotorState\030\004 \001(\0132\026.abb"
  ".egm.EgmMotorState\022&\n\010mciState\030\005 \001(\0132\024.a"
  "bb.egm.EgmMCIState\022\031\n\021mciConvergenceMet\030"
  "\006 \001(\010\022,\n\013testSignals\030\007 \001(\0132\027.abb.egm.Egm"
  "TestSignals\0226\n\016rapidExecState\030\010 \001(\0132\036.ab"
  "b.egm.EgmRapidCtrlExecState\0220\n\rmeasuredF"
  "orce\030\t \001(\0132\031.abb.egm.EgmMeasuredForce\022\027\n"
  "\017utilizationRate\030\n \001(\001\022\021\n\tmoveIndex\030\013 \001("
  "\r\0220\n\rCollisionInfo\030\014 \001(\0132\031.abb.egm.EgmCo"
  "llisionInfo\022-\n\016RAPIDfromRobot\030\r \001(\0132\025.ab"
  "b.egm.EgmRAPIDdata\"\252\001\n\tEgmSensor\022\"\n\006head"
  "er\030\001 \001(\0132\022.abb.egm.EgmHeader\022$\n\007planned\030"
  "\002 \001(\0132\023.abb.egm.EgmPlanned\022&\n\010speedRef\030\003"
  " \001(\0132\024.abb.egm.EgmSpeedRef\022+\n\014RAPIDtoRob"
  "ot\030\004 \001(\0132\025.abb.egm.EgmRAPIDdata\"_\n\021EgmSe"
  "nsorPathCorr\022\"\n\006header\030\001 \001(\0132\022.abb.egm.E"
  "gmHeader\022&\n\010pathCorr\030\002 \001(\0132\024.abb.egm.Egm"
  "PathCorr"
  ;
static ::_pbi::once_flag descriptor_table_egm_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_egm_2eproto = {
    false, false, 2728, descriptor_table_protodef_egm_2eproto,
    "egm.proto",
    &descriptor_table_egm_2eproto_once, nullptr, 0, 23,
    schemas, file_default_instances, TableStruct_egm_2eproto::offsets,
    file_level_metadata_egm_2eproto, file_level_enum_descriptors_egm_2eproto,
    file_level_service_descriptors_egm_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_egm_2eproto_getter() {
  return &descriptor_table_egm_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_egm_2eproto(&descriptor_table_egm_2eproto);
namespace abb {
namespace egm {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmHeader_MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[0];
}
bool EgmHeader_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_UNDEFINED;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_COMMAND;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_DATA;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_CORRECTION;
constexpr EgmHeader_MessageType EgmHeader::MSGTYPE_PATH_CORRECTION;
constexpr EgmHeader_MessageType EgmHeader::MessageType_MIN;
constexpr EgmHeader_MessageType EgmHeader::MessageType_MAX;
constexpr int EgmHeader::MessageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMotorState_MotorStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[1];
}
bool EgmMotorState_MotorStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_UNDEFINED;
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_ON;
constexpr EgmMotorState_MotorStateType EgmMotorState::MOTORS_OFF;
constexpr EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MIN;
constexpr EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MAX;
constexpr int EgmMotorState::MotorStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmMCIState_MCIStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[2];
}
bool EgmMCIState_MCIStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_UNDEFINED;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_ERROR;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_STOPPED;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCI_RUNNING;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MIN;
constexpr EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MAX;
constexpr int EgmMCIState::MCIStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_egm_2eproto);
  return file_level_enum_descriptors_egm_2eproto[3];
}
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_UNDEFINED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_STOPPED;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_RUNNING;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MIN;
constexpr EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MAX;
constexpr int EgmRapidCtrlExecState::RapidCtrlExecStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class EgmHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmHeader>()._impl_._has_bits_);
  static void set_has_seqno(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

EgmHeader::EgmHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmHeader)
}
EgmHeader::EgmHeader(const EgmHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqno_){}
    , decltype(_impl_.tm_){}
    , decltype(_impl_.mtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.seqno_, &from._impl_.seqno_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mtype_) -
    reinterpret_cast<char*>(&_impl_.seqno_)) + sizeof(_impl_.mtype_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmHeader)
}

inline void EgmHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seqno_){0u}
    , decltype(_impl_.tm_){0u}
    , decltype(_impl_.mtype_){0}
  };
}

EgmHeader::~EgmHeader() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.seqno_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mtype_) -
        reinterpret_cast<char*>(&_impl_.seqno_)) + sizeof(_impl_.mtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 seqno = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seqno(&has_bits);
          _impl_.seqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tm(&has_bits);
          _impl_.tm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmHeader_MessageType_IsValid(val))) {
            _internal_set_mtype(static_cast<::abb::egm::EgmHeader_MessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 seqno = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_seqno(), target);
  }

  // optional uint32 tm = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tm(), target);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmHeader)
  return target;
}

size_t EgmHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 seqno = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seqno());
    }

    // optional uint32 tm = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tm());
    }

    // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmHeader::GetClassData() const { return &_class_data_; }


void EgmHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmHeader*>(&to_msg);
  auto& from = static_cast<const EgmHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.seqno_ = from._impl_.seqno_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tm_ = from._impl_.tm_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mtype_ = from._impl_.mtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmHeader::CopyFrom(const EgmHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmHeader::IsInitialized() const {
  return true;
}

void EgmHeader::InternalSwap(EgmHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmHeader, _impl_.mtype_)
      + sizeof(EgmHeader::_impl_.mtype_)
      - PROTOBUF_FIELD_OFFSET(EgmHeader, _impl_.seqno_)>(
          reinterpret_cast<char*>(&_impl_.seqno_),
          reinterpret_cast<char*>(&other->_impl_.seqno_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[0]);
}

// ===================================================================

class EgmCartesian::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmCartesian>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

EgmCartesian::EgmCartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmCartesian)
}
EgmCartesian::EgmCartesian(const EgmCartesian& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmCartesian* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesian)
}

inline void EgmCartesian::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

EgmCartesian::~EgmCartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesian)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmCartesian::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmCartesian::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmCartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesian)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmCartesian::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmCartesian::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesian)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesian)
  return target;
}

size_t EgmCartesian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmCartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmCartesian::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmCartesian::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmCartesian::GetClassData() const { return &_class_data_; }


void EgmCartesian::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmCartesian*>(&to_msg);
  auto& from = static_cast<const EgmCartesian&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesian)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmCartesian::CopyFrom(const EgmCartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesian::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmCartesian::InternalSwap(EgmCartesian* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmCartesian, _impl_.z_)
      + sizeof(EgmCartesian::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(EgmCartesian, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmCartesian::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[1]);
}

// ===================================================================

class EgmQuaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmQuaternion>()._impl_._has_bits_);
  static void set_has_u0(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_u1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_u2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_u3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

EgmQuaternion::EgmQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmQuaternion)
}
EgmQuaternion::EgmQuaternion(const EgmQuaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmQuaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u0_){}
    , decltype(_impl_.u1_){}
    , decltype(_impl_.u2_){}
    , decltype(_impl_.u3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.u0_, &from._impl_.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u3_) -
    reinterpret_cast<char*>(&_impl_.u0_)) + sizeof(_impl_.u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmQuaternion)
}

inline void EgmQuaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u0_){0}
    , decltype(_impl_.u1_){0}
    , decltype(_impl_.u2_){0}
    , decltype(_impl_.u3_){0}
  };
}

EgmQuaternion::~EgmQuaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmQuaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmQuaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmQuaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmQuaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmQuaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.u3_) -
        reinterpret_cast<char*>(&_impl_.u0_)) + sizeof(_impl_.u3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmQuaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double u0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_u0(&has_bits);
          _impl_.u0_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double u1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_u1(&has_bits);
          _impl_.u1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double u2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_u2(&has_bits);
          _impl_.u2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double u3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_u3(&has_bits);
          _impl_.u3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmQuaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmQuaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_u0(), target);
  }

  // required double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_u1(), target);
  }

  // required double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_u2(), target);
  }

  // required double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_u3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmQuaternion)
  return target;
}

size_t EgmQuaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (_internal_has_u0()) {
    // required double u0 = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_u1()) {
    // required double u1 = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_u2()) {
    // required double u2 = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_u3()) {
    // required double u3 = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmQuaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double u0 = 1;
    total_size += 1 + 8;

    // required double u1 = 2;
    total_size += 1 + 8;

    // required double u2 = 3;
    total_size += 1 + 8;

    // required double u3 = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmQuaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmQuaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmQuaternion::GetClassData() const { return &_class_data_; }


void EgmQuaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmQuaternion*>(&to_msg);
  auto& from = static_cast<const EgmQuaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmQuaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.u0_ = from._impl_.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.u1_ = from._impl_.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.u2_ = from._impl_.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.u3_ = from._impl_.u3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmQuaternion::CopyFrom(const EgmQuaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmQuaternion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmQuaternion::InternalSwap(EgmQuaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmQuaternion, _impl_.u3_)
      + sizeof(EgmQuaternion::_impl_.u3_)
      - PROTOBUF_FIELD_OFFSET(EgmQuaternion, _impl_.u0_)>(
          reinterpret_cast<char*>(&_impl_.u0_),
          reinterpret_cast<char*>(&other->_impl_.u0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmQuaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[2]);
}

// ===================================================================

class EgmEuler::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmEuler>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

EgmEuler::EgmEuler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmEuler)
}
EgmEuler::EgmEuler(const EgmEuler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmEuler* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmEuler)
}

inline void EgmEuler::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

EgmEuler::~EgmEuler() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmEuler)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmEuler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmEuler::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmEuler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmEuler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmEuler::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmEuler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmEuler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmEuler)
  return target;
}

size_t EgmEuler::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmEuler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmEuler::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmEuler::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmEuler::GetClassData() const { return &_class_data_; }


void EgmEuler::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmEuler*>(&to_msg);
  auto& from = static_cast<const EgmEuler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmEuler)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmEuler::CopyFrom(const EgmEuler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmEuler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmEuler::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmEuler::InternalSwap(EgmEuler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmEuler, _impl_.z_)
      + sizeof(EgmEuler::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(EgmEuler, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmEuler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[3]);
}

// ===================================================================

class EgmClock::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmClock>()._impl_._has_bits_);
  static void set_has_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EgmClock::EgmClock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmClock)
}
EgmClock::EgmClock(const EgmClock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmClock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sec_){}
    , decltype(_impl_.usec_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sec_, &from._impl_.sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.usec_) -
    reinterpret_cast<char*>(&_impl_.sec_)) + sizeof(_impl_.usec_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmClock)
}

inline void EgmClock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sec_){uint64_t{0u}}
    , decltype(_impl_.usec_){uint64_t{0u}}
  };
}

EgmClock::~EgmClock() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmClock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmClock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmClock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmClock::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmClock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.usec_) -
        reinterpret_cast<char*>(&_impl_.sec_)) + sizeof(_impl_.usec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmClock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 sec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sec(&has_bits);
          _impl_.sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_usec(&has_bits);
          _impl_.usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmClock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmClock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sec(), target);
  }

  // required uint64 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmClock)
  return target;
}

size_t EgmClock::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmClock)
  size_t total_size = 0;

  if (_internal_has_sec()) {
    // required uint64 sec = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sec());
  }

  if (_internal_has_usec()) {
    // required uint64 usec = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_usec());
  }

  return total_size;
}
size_t EgmClock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmClock)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 sec = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sec());

    // required uint64 usec = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_usec());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmClock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmClock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmClock::GetClassData() const { return &_class_data_; }


void EgmClock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmClock*>(&to_msg);
  auto& from = static_cast<const EgmClock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmClock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sec_ = from._impl_.sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.usec_ = from._impl_.usec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmClock::CopyFrom(const EgmClock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmClock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmClock::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmClock::InternalSwap(EgmClock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmClock, _impl_.usec_)
      + sizeof(EgmClock::_impl_.usec_)
      - PROTOBUF_FIELD_OFFSET(EgmClock, _impl_.sec_)>(
          reinterpret_cast<char*>(&_impl_.sec_),
          reinterpret_cast<char*>(&other->_impl_.sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmClock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[4]);
}

// ===================================================================

class EgmPose::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPose>()._impl_._has_bits_);
  static const ::abb::egm::EgmCartesian& pos(const EgmPose* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmQuaternion& orient(const EgmPose* msg);
  static void set_has_orient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmEuler& euler(const EgmPose* msg);
  static void set_has_euler(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::egm::EgmCartesian&
EgmPose::_Internal::pos(const EgmPose* msg) {
  return *msg->_impl_.pos_;
}
const ::abb::egm::EgmQuaternion&
EgmPose::_Internal::orient(const EgmPose* msg) {
  return *msg->_impl_.orient_;
}
const ::abb::egm::EgmEuler&
EgmPose::_Internal::euler(const EgmPose* msg) {
  return *msg->_impl_.euler_;
}
EgmPose::EgmPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPose)
}
EgmPose::EgmPose(const EgmPose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmPose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.orient_){nullptr}
    , decltype(_impl_.euler_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::abb::egm::EgmCartesian(*from._impl_.pos_);
  }
  if (from._internal_has_orient()) {
    _this->_impl_.orient_ = new ::abb::egm::EgmQuaternion(*from._impl_.orient_);
  }
  if (from._internal_has_euler()) {
    _this->_impl_.euler_ = new ::abb::egm::EgmEuler(*from._impl_.euler_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPose)
}

inline void EgmPose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.orient_){nullptr}
    , decltype(_impl_.euler_){nullptr}
  };
}

EgmPose::~EgmPose() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmPose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.orient_;
  if (this != internal_default_instance()) delete _impl_.euler_;
}

void EgmPose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.orient_ != nullptr);
      _impl_.orient_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.euler_ != nullptr);
      _impl_.euler_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmCartesian pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmQuaternion orient = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmEuler euler = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_euler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmPose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orient(this),
        _Internal::orient(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::euler(this),
        _Internal::euler(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPose)
  return target;
}

size_t EgmPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.EgmCartesian pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional .abb.egm.EgmQuaternion orient = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.orient_);
    }

    // optional .abb.egm.EgmEuler euler = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.euler_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmPose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmPose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmPose::GetClassData() const { return &_class_data_; }


void EgmPose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmPose*>(&to_msg);
  auto& from = static_cast<const EgmPose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_orient()->::abb::egm::EgmQuaternion::MergeFrom(
          from._internal_orient());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_euler()->::abb::egm::EgmEuler::MergeFrom(
          from._internal_euler());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmPose::CopyFrom(const EgmPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPose::IsInitialized() const {
  if (_internal_has_pos()) {
    if (!_impl_.pos_->IsInitialized()) return false;
  }
  if (_internal_has_orient()) {
    if (!_impl_.orient_->IsInitialized()) return false;
  }
  if (_internal_has_euler()) {
    if (!_impl_.euler_->IsInitialized()) return false;
  }
  return true;
}

void EgmPose::InternalSwap(EgmPose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPose, _impl_.euler_)
      + sizeof(EgmPose::_impl_.euler_)
      - PROTOBUF_FIELD_OFFSET(EgmPose, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[5]);
}

// ===================================================================

class EgmCartesianSpeed::_Internal {
 public:
};

EgmCartesianSpeed::EgmCartesianSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmCartesianSpeed)
}
EgmCartesianSpeed::EgmCartesianSpeed(const EgmCartesianSpeed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmCartesianSpeed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){from._impl_.value_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesianSpeed)
}

inline void EgmCartesianSpeed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EgmCartesianSpeed::~EgmCartesianSpeed() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesianSpeed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmCartesianSpeed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.~RepeatedField();
}

void EgmCartesianSpeed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmCartesianSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesianSpeed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmCartesianSpeed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_value(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmCartesianSpeed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesianSpeed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_value(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesianSpeed)
  return target;
}

size_t EgmCartesianSpeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesianSpeed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double value = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_value_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_value_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmCartesianSpeed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmCartesianSpeed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmCartesianSpeed::GetClassData() const { return &_class_data_; }


void EgmCartesianSpeed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmCartesianSpeed*>(&to_msg);
  auto& from = static_cast<const EgmCartesianSpeed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesianSpeed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.value_.MergeFrom(from._impl_.value_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmCartesianSpeed::CopyFrom(const EgmCartesianSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesianSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesianSpeed::IsInitialized() const {
  return true;
}

void EgmCartesianSpeed::InternalSwap(EgmCartesianSpeed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.value_.InternalSwap(&other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmCartesianSpeed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[6]);
}

// ===================================================================

class EgmJoints::_Internal {
 public:
};

EgmJoints::EgmJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmJoints)
}
EgmJoints::EgmJoints(const EgmJoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmJoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.joints_){from._impl_.joints_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmJoints)
}

inline void EgmJoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.joints_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EgmJoints::~EgmJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmJoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmJoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.joints_.~RepeatedField();
}

void EgmJoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmJoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.joints_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmJoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joints(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joints(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmJoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmJoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->_internal_joints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_joints(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmJoints)
  return target;
}

size_t EgmJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmJoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_joints_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmJoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmJoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmJoints::GetClassData() const { return &_class_data_; }


void EgmJoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmJoints*>(&to_msg);
  auto& from = static_cast<const EgmJoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmJoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.joints_.MergeFrom(from._impl_.joints_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmJoints::CopyFrom(const EgmJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmJoints::IsInitialized() const {
  return true;
}

void EgmJoints::InternalSwap(EgmJoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.joints_.InternalSwap(&other->_impl_.joints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmJoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[7]);
}

// ===================================================================

class EgmExternalJoints::_Internal {
 public:
};

EgmExternalJoints::EgmExternalJoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmExternalJoints)
}
EgmExternalJoints::EgmExternalJoints(const EgmExternalJoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmExternalJoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.joints_){from._impl_.joints_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmExternalJoints)
}

inline void EgmExternalJoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.joints_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EgmExternalJoints::~EgmExternalJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmExternalJoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmExternalJoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.joints_.~RepeatedField();
}

void EgmExternalJoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmExternalJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmExternalJoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.joints_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmExternalJoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_joints(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_joints(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmExternalJoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmExternalJoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->_internal_joints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_joints(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmExternalJoints)
  return target;
}

size_t EgmExternalJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmExternalJoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_joints_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmExternalJoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmExternalJoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmExternalJoints::GetClassData() const { return &_class_data_; }


void EgmExternalJoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmExternalJoints*>(&to_msg);
  auto& from = static_cast<const EgmExternalJoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmExternalJoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.joints_.MergeFrom(from._impl_.joints_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmExternalJoints::CopyFrom(const EgmExternalJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmExternalJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmExternalJoints::IsInitialized() const {
  return true;
}

void EgmExternalJoints::InternalSwap(EgmExternalJoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.joints_.InternalSwap(&other->_impl_.joints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmExternalJoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[8]);
}

// ===================================================================

class EgmPlanned::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPlanned>()._impl_._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmPlanned* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPose& cartesian(const EgmPlanned* msg);
  static void set_has_cartesian(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmPlanned* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmClock& time(const EgmPlanned* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::abb::egm::EgmJoints&
EgmPlanned::_Internal::joints(const EgmPlanned* msg) {
  return *msg->_impl_.joints_;
}
const ::abb::egm::EgmPose&
EgmPlanned::_Internal::cartesian(const EgmPlanned* msg) {
  return *msg->_impl_.cartesian_;
}
const ::abb::egm::EgmJoints&
EgmPlanned::_Internal::externaljoints(const EgmPlanned* msg) {
  return *msg->_impl_.externaljoints_;
}
const ::abb::egm::EgmClock&
EgmPlanned::_Internal::time(const EgmPlanned* msg) {
  return *msg->_impl_.time_;
}
EgmPlanned::EgmPlanned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPlanned)
}
EgmPlanned::EgmPlanned(const EgmPlanned& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmPlanned* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesian_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}
    , decltype(_impl_.time_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    _this->_impl_.joints_ = new ::abb::egm::EgmJoints(*from._impl_.joints_);
  }
  if (from._internal_has_cartesian()) {
    _this->_impl_.cartesian_ = new ::abb::egm::EgmPose(*from._impl_.cartesian_);
  }
  if (from._internal_has_externaljoints()) {
    _this->_impl_.externaljoints_ = new ::abb::egm::EgmJoints(*from._impl_.externaljoints_);
  }
  if (from._internal_has_time()) {
    _this->_impl_.time_ = new ::abb::egm::EgmClock(*from._impl_.time_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPlanned)
}

inline void EgmPlanned::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesian_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}
    , decltype(_impl_.time_){nullptr}
  };
}

EgmPlanned::~EgmPlanned() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPlanned)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmPlanned::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.joints_;
  if (this != internal_default_instance()) delete _impl_.cartesian_;
  if (this != internal_default_instance()) delete _impl_.externaljoints_;
  if (this != internal_default_instance()) delete _impl_.time_;
}

void EgmPlanned::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmPlanned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPlanned)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.joints_ != nullptr);
      _impl_.joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cartesian_ != nullptr);
      _impl_.cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.externaljoints_ != nullptr);
      _impl_.externaljoints_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPlanned::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPose cartesian = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesian(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmClock time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmPlanned::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPlanned)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::joints(this),
        _Internal::joints(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cartesian(this),
        _Internal::cartesian(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::externaljoints(this),
        _Internal::externaljoints(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmClock time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::time(this),
        _Internal::time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPlanned)
  return target;
}

size_t EgmPlanned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPlanned)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.externaljoints_);
    }

    // optional .abb.egm.EgmClock time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmPlanned::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmPlanned::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmPlanned::GetClassData() const { return &_class_data_; }


void EgmPlanned::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmPlanned*>(&to_msg);
  auto& from = static_cast<const EgmPlanned&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPlanned)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(
          from._internal_cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_externaljoints());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_time()->::abb::egm::EgmClock::MergeFrom(
          from._internal_time());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmPlanned::CopyFrom(const EgmPlanned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPlanned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPlanned::IsInitialized() const {
  if (_internal_has_cartesian()) {
    if (!_impl_.cartesian_->IsInitialized()) return false;
  }
  if (_internal_has_time()) {
    if (!_impl_.time_->IsInitialized()) return false;
  }
  return true;
}

void EgmPlanned::InternalSwap(EgmPlanned* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPlanned, _impl_.time_)
      + sizeof(EgmPlanned::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(EgmPlanned, _impl_.joints_)>(
          reinterpret_cast<char*>(&_impl_.joints_),
          reinterpret_cast<char*>(&other->_impl_.joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPlanned::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[9]);
}

// ===================================================================

class EgmSpeedRef::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSpeedRef>()._impl_._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmSpeedRef* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmCartesianSpeed& cartesians(const EgmSpeedRef* msg);
  static void set_has_cartesians(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmSpeedRef* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::abb::egm::EgmJoints&
EgmSpeedRef::_Internal::joints(const EgmSpeedRef* msg) {
  return *msg->_impl_.joints_;
}
const ::abb::egm::EgmCartesianSpeed&
EgmSpeedRef::_Internal::cartesians(const EgmSpeedRef* msg) {
  return *msg->_impl_.cartesians_;
}
const ::abb::egm::EgmJoints&
EgmSpeedRef::_Internal::externaljoints(const EgmSpeedRef* msg) {
  return *msg->_impl_.externaljoints_;
}
EgmSpeedRef::EgmSpeedRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSpeedRef)
}
EgmSpeedRef::EgmSpeedRef(const EgmSpeedRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmSpeedRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesians_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    _this->_impl_.joints_ = new ::abb::egm::EgmJoints(*from._impl_.joints_);
  }
  if (from._internal_has_cartesians()) {
    _this->_impl_.cartesians_ = new ::abb::egm::EgmCartesianSpeed(*from._impl_.cartesians_);
  }
  if (from._internal_has_externaljoints()) {
    _this->_impl_.externaljoints_ = new ::abb::egm::EgmJoints(*from._impl_.externaljoints_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSpeedRef)
}

inline void EgmSpeedRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesians_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}
  };
}

EgmSpeedRef::~EgmSpeedRef() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSpeedRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmSpeedRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.joints_;
  if (this != internal_default_instance()) delete _impl_.cartesians_;
  if (this != internal_default_instance()) delete _impl_.externaljoints_;
}

void EgmSpeedRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmSpeedRef::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSpeedRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.joints_ != nullptr);
      _impl_.joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cartesians_ != nullptr);
      _impl_.cartesians_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.externaljoints_ != nullptr);
      _impl_.externaljoints_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSpeedRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesians(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmSpeedRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSpeedRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::joints(this),
        _Internal::joints(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cartesians(this),
        _Internal::cartesians(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::externaljoints(this),
        _Internal::externaljoints(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSpeedRef)
  return target;
}

size_t EgmSpeedRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSpeedRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.joints_);
    }

    // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cartesians_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.externaljoints_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmSpeedRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmSpeedRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmSpeedRef::GetClassData() const { return &_class_data_; }


void EgmSpeedRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmSpeedRef*>(&to_msg);
  auto& from = static_cast<const EgmSpeedRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSpeedRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cartesians()->::abb::egm::EgmCartesianSpeed::MergeFrom(
          from._internal_cartesians());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_externaljoints());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmSpeedRef::CopyFrom(const EgmSpeedRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSpeedRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSpeedRef::IsInitialized() const {
  return true;
}

void EgmSpeedRef::InternalSwap(EgmSpeedRef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSpeedRef, _impl_.externaljoints_)
      + sizeof(EgmSpeedRef::_impl_.externaljoints_)
      - PROTOBUF_FIELD_OFFSET(EgmSpeedRef, _impl_.joints_)>(
          reinterpret_cast<char*>(&_impl_.joints_),
          reinterpret_cast<char*>(&other->_impl_.joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSpeedRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[10]);
}

// ===================================================================

class EgmPathCorr::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmPathCorr>()._impl_._has_bits_);
  static const ::abb::egm::EgmCartesian& pos(const EgmPathCorr* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_age(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::abb::egm::EgmCartesian&
EgmPathCorr::_Internal::pos(const EgmPathCorr* msg) {
  return *msg->_impl_.pos_;
}
EgmPathCorr::EgmPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmPathCorr)
}
EgmPathCorr::EgmPathCorr(const EgmPathCorr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmPathCorr* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.age_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::abb::egm::EgmCartesian(*from._impl_.pos_);
  }
  _this->_impl_.age_ = from._impl_.age_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPathCorr)
}

inline void EgmPathCorr::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.age_){0u}
  };
}

EgmPathCorr::~EgmPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPathCorr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmPathCorr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void EgmPathCorr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPathCorr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  _impl_.age_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmPathCorr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .abb.egm.EgmCartesian pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 age = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_age(&has_bits);
          _impl_.age_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmPathCorr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPathCorr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // required uint32 age = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_age(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPathCorr)
  return target;
}

size_t EgmPathCorr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (_internal_has_pos()) {
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  if (_internal_has_age()) {
    // required uint32 age = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_age());
  }

  return total_size;
}
size_t EgmPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);

    // required uint32 age = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_age());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmPathCorr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmPathCorr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmPathCorr::GetClassData() const { return &_class_data_; }


void EgmPathCorr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmPathCorr*>(&to_msg);
  auto& from = static_cast<const EgmPathCorr&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPathCorr)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.age_ = from._impl_.age_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmPathCorr::CopyFrom(const EgmPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPathCorr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_pos()) {
    if (!_impl_.pos_->IsInitialized()) return false;
  }
  return true;
}

void EgmPathCorr::InternalSwap(EgmPathCorr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmPathCorr, _impl_.age_)
      + sizeof(EgmPathCorr::_impl_.age_)
      - PROTOBUF_FIELD_OFFSET(EgmPathCorr, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmPathCorr::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[11]);
}

// ===================================================================

class EgmFeedBack::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmFeedBack>()._impl_._has_bits_);
  static const ::abb::egm::EgmJoints& joints(const EgmFeedBack* msg);
  static void set_has_joints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPose& cartesian(const EgmFeedBack* msg);
  static void set_has_cartesian(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmJoints& externaljoints(const EgmFeedBack* msg);
  static void set_has_externaljoints(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmClock& time(const EgmFeedBack* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::abb::egm::EgmJoints&
EgmFeedBack::_Internal::joints(const EgmFeedBack* msg) {
  return *msg->_impl_.joints_;
}
const ::abb::egm::EgmPose&
EgmFeedBack::_Internal::cartesian(const EgmFeedBack* msg) {
  return *msg->_impl_.cartesian_;
}
const ::abb::egm::EgmJoints&
EgmFeedBack::_Internal::externaljoints(const EgmFeedBack* msg) {
  return *msg->_impl_.externaljoints_;
}
const ::abb::egm::EgmClock&
EgmFeedBack::_Internal::time(const EgmFeedBack* msg) {
  return *msg->_impl_.time_;
}
EgmFeedBack::EgmFeedBack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmFeedBack)
}
EgmFeedBack::EgmFeedBack(const EgmFeedBack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmFeedBack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesian_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}
    , decltype(_impl_.time_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_joints()) {
    _this->_impl_.joints_ = new ::abb::egm::EgmJoints(*from._impl_.joints_);
  }
  if (from._internal_has_cartesian()) {
    _this->_impl_.cartesian_ = new ::abb::egm::EgmPose(*from._impl_.cartesian_);
  }
  if (from._internal_has_externaljoints()) {
    _this->_impl_.externaljoints_ = new ::abb::egm::EgmJoints(*from._impl_.externaljoints_);
  }
  if (from._internal_has_time()) {
    _this->_impl_.time_ = new ::abb::egm::EgmClock(*from._impl_.time_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmFeedBack)
}

inline void EgmFeedBack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.cartesian_){nullptr}
    , decltype(_impl_.externaljoints_){nullptr}
    , decltype(_impl_.time_){nullptr}
  };
}

EgmFeedBack::~EgmFeedBack() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmFeedBack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmFeedBack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.joints_;
  if (this != internal_default_instance()) delete _impl_.cartesian_;
  if (this != internal_default_instance()) delete _impl_.externaljoints_;
  if (this != internal_default_instance()) delete _impl_.time_;
}

void EgmFeedBack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmFeedBack::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmFeedBack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.joints_ != nullptr);
      _impl_.joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cartesian_ != nullptr);
      _impl_.cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.externaljoints_ != nullptr);
      _impl_.externaljoints_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmFeedBack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPose cartesian = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartesian(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_externaljoints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmClock time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmFeedBack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmFeedBack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::joints(this),
        _Internal::joints(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cartesian(this),
        _Internal::cartesian(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::externaljoints(this),
        _Internal::externaljoints(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmClock time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::time(this),
        _Internal::time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmFeedBack)
  return target;
}

size_t EgmFeedBack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmFeedBack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.externaljoints_);
    }

    // optional .abb.egm.EgmClock time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmFeedBack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmFeedBack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmFeedBack::GetClassData() const { return &_class_data_; }


void EgmFeedBack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmFeedBack*>(&to_msg);
  auto& from = static_cast<const EgmFeedBack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmFeedBack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_joints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_joints());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(
          from._internal_cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(
          from._internal_externaljoints());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_time()->::abb::egm::EgmClock::MergeFrom(
          from._internal_time());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmFeedBack::CopyFrom(const EgmFeedBack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmFeedBack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmFeedBack::IsInitialized() const {
  if (_internal_has_cartesian()) {
    if (!_impl_.cartesian_->IsInitialized()) return false;
  }
  if (_internal_has_time()) {
    if (!_impl_.time_->IsInitialized()) return false;
  }
  return true;
}

void EgmFeedBack::InternalSwap(EgmFeedBack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmFeedBack, _impl_.time_)
      + sizeof(EgmFeedBack::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(EgmFeedBack, _impl_.joints_)>(
          reinterpret_cast<char*>(&_impl_.joints_),
          reinterpret_cast<char*>(&other->_impl_.joints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmFeedBack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[12]);
}

// ===================================================================

class EgmMotorState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmMotorState>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmMotorState::EgmMotorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMotorState)
}
EgmMotorState::EgmMotorState(const EgmMotorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmMotorState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMotorState)
}

inline void EgmMotorState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0}
  };
}

EgmMotorState::~EgmMotorState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMotorState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmMotorState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmMotorState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmMotorState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMotorState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMotorState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .abb.egm.EgmMotorState.MotorStateType state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmMotorState_MotorStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmMotorState_MotorStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmMotorState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMotorState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMotorState)
  return target;
}

size_t EgmMotorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMotorState)
  size_t total_size = 0;

  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (_internal_has_state()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmMotorState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmMotorState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmMotorState::GetClassData() const { return &_class_data_; }


void EgmMotorState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmMotorState*>(&to_msg);
  auto& from = static_cast<const EgmMotorState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMotorState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmMotorState::CopyFrom(const EgmMotorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMotorState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmMotorState::InternalSwap(EgmMotorState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMotorState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[13]);
}

// ===================================================================

class EgmMCIState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmMCIState>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmMCIState::EgmMCIState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMCIState)
}
EgmMCIState::EgmMCIState(const EgmMCIState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmMCIState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMCIState)
}

inline void EgmMCIState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0}
  };
}

EgmMCIState::~EgmMCIState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMCIState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmMCIState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmMCIState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmMCIState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMCIState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMCIState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmMCIState_MCIStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmMCIState_MCIStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmMCIState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMCIState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMCIState)
  return target;
}

size_t EgmMCIState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMCIState)
  size_t total_size = 0;

  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (_internal_has_state()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmMCIState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmMCIState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmMCIState::GetClassData() const { return &_class_data_; }


void EgmMCIState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmMCIState*>(&to_msg);
  auto& from = static_cast<const EgmMCIState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMCIState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmMCIState::CopyFrom(const EgmMCIState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMCIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMCIState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmMCIState::InternalSwap(EgmMCIState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMCIState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[14]);
}

// ===================================================================

class EgmRapidCtrlExecState::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmRapidCtrlExecState>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EgmRapidCtrlExecState::EgmRapidCtrlExecState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmRapidCtrlExecState)
}
EgmRapidCtrlExecState::EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmRapidCtrlExecState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRapidCtrlExecState)
}

inline void EgmRapidCtrlExecState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0}
  };
}

EgmRapidCtrlExecState::~EgmRapidCtrlExecState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRapidCtrlExecState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmRapidCtrlExecState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EgmRapidCtrlExecState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmRapidCtrlExecState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRapidCtrlExecState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmRapidCtrlExecState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(val))) {
            _internal_set_state(static_cast<::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmRapidCtrlExecState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRapidCtrlExecState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRapidCtrlExecState)
  return target;
}

size_t EgmRapidCtrlExecState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRapidCtrlExecState)
  size_t total_size = 0;

  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (_internal_has_state()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmRapidCtrlExecState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmRapidCtrlExecState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmRapidCtrlExecState::GetClassData() const { return &_class_data_; }


void EgmRapidCtrlExecState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmRapidCtrlExecState*>(&to_msg);
  auto& from = static_cast<const EgmRapidCtrlExecState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRapidCtrlExecState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmRapidCtrlExecState::CopyFrom(const EgmRapidCtrlExecState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRapidCtrlExecState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRapidCtrlExecState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EgmRapidCtrlExecState::InternalSwap(EgmRapidCtrlExecState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmRapidCtrlExecState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[15]);
}

// ===================================================================

class EgmTestSignals::_Internal {
 public:
};

EgmTestSignals::EgmTestSignals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmTestSignals)
}
EgmTestSignals::EgmTestSignals(const EgmTestSignals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmTestSignals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){from._impl_.signals_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmTestSignals)
}

inline void EgmTestSignals::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signals_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EgmTestSignals::~EgmTestSignals() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmTestSignals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmTestSignals::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signals_.~RepeatedField();
}

void EgmTestSignals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmTestSignals::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmTestSignals)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmTestSignals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double signals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_signals(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_signals(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmTestSignals::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmTestSignals)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double signals = 1;
  for (int i = 0, n = this->_internal_signals_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_signals(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmTestSignals)
  return target;
}

size_t EgmTestSignals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmTestSignals)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double signals = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_signals_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_signals_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmTestSignals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmTestSignals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmTestSignals::GetClassData() const { return &_class_data_; }


void EgmTestSignals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmTestSignals*>(&to_msg);
  auto& from = static_cast<const EgmTestSignals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmTestSignals)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmTestSignals::CopyFrom(const EgmTestSignals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmTestSignals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmTestSignals::IsInitialized() const {
  return true;
}

void EgmTestSignals::InternalSwap(EgmTestSignals* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.signals_.InternalSwap(&other->_impl_.signals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmTestSignals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[16]);
}

// ===================================================================

class EgmMeasuredForce::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmMeasuredForce>()._impl_._has_bits_);
  static void set_has_fcactive(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EgmMeasuredForce::EgmMeasuredForce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmMeasuredForce)
}
EgmMeasuredForce::EgmMeasuredForce(const EgmMeasuredForce& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmMeasuredForce* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.force_){from._impl_.force_}
    , decltype(_impl_.fcactive_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.fcactive_ = from._impl_.fcactive_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMeasuredForce)
}

inline void EgmMeasuredForce::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.force_){arena}
    , decltype(_impl_.fcactive_){false}
  };
}

EgmMeasuredForce::~EgmMeasuredForce() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMeasuredForce)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmMeasuredForce::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.force_.~RepeatedField();
}

void EgmMeasuredForce::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmMeasuredForce::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMeasuredForce)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.force_.Clear();
  _impl_.fcactive_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmMeasuredForce::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool fcActive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_fcactive(&has_bits);
          _impl_.fcactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double force = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_force(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_force(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmMeasuredForce::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMeasuredForce)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool fcActive = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_fcactive(), target);
  }

  // repeated double force = 2;
  for (int i = 0, n = this->_internal_force_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_force(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMeasuredForce)
  return target;
}

size_t EgmMeasuredForce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMeasuredForce)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double force = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_force_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_force_size());
    total_size += data_size;
  }

  // optional bool fcActive = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmMeasuredForce::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmMeasuredForce::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmMeasuredForce::GetClassData() const { return &_class_data_; }


void EgmMeasuredForce::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmMeasuredForce*>(&to_msg);
  auto& from = static_cast<const EgmMeasuredForce&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMeasuredForce)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.force_.MergeFrom(from._impl_.force_);
  if (from._internal_has_fcactive()) {
    _this->_internal_set_fcactive(from._internal_fcactive());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmMeasuredForce::CopyFrom(const EgmMeasuredForce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMeasuredForce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMeasuredForce::IsInitialized() const {
  return true;
}

void EgmMeasuredForce::InternalSwap(EgmMeasuredForce* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.force_.InternalSwap(&other->_impl_.force_);
  swap(_impl_.fcactive_, other->_impl_.fcactive_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmMeasuredForce::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[17]);
}

// ===================================================================

class EgmCollisionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmCollisionInfo>()._impl_._has_bits_);
  static void set_has_collsiontriggered(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EgmCollisionInfo::EgmCollisionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmCollisionInfo)
}
EgmCollisionInfo::EgmCollisionInfo(const EgmCollisionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmCollisionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.colldetquota_){from._impl_.colldetquota_}
    , decltype(_impl_.collsiontriggered_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.collsiontriggered_ = from._impl_.collsiontriggered_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCollisionInfo)
}

inline void EgmCollisionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.colldetquota_){arena}
    , decltype(_impl_.collsiontriggered_){false}
  };
}

EgmCollisionInfo::~EgmCollisionInfo() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCollisionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmCollisionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.colldetquota_.~RepeatedField();
}

void EgmCollisionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmCollisionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCollisionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.colldetquota_.Clear();
  _impl_.collsiontriggered_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmCollisionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool collsionTriggered = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_collsiontriggered(&has_bits);
          _impl_.collsiontriggered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double collDetQuota = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_colldetquota(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_colldetquota(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmCollisionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCollisionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool collsionTriggered = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_collsiontriggered(), target);
  }

  // repeated double collDetQuota = 2;
  for (int i = 0, n = this->_internal_colldetquota_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_colldetquota(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCollisionInfo)
  return target;
}

size_t EgmCollisionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCollisionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double collDetQuota = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_colldetquota_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_colldetquota_size());
    total_size += data_size;
  }

  // optional bool collsionTriggered = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmCollisionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmCollisionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmCollisionInfo::GetClassData() const { return &_class_data_; }


void EgmCollisionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmCollisionInfo*>(&to_msg);
  auto& from = static_cast<const EgmCollisionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCollisionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.colldetquota_.MergeFrom(from._impl_.colldetquota_);
  if (from._internal_has_collsiontriggered()) {
    _this->_internal_set_collsiontriggered(from._internal_collsiontriggered());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmCollisionInfo::CopyFrom(const EgmCollisionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCollisionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCollisionInfo::IsInitialized() const {
  return true;
}

void EgmCollisionInfo::InternalSwap(EgmCollisionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.colldetquota_.InternalSwap(&other->_impl_.colldetquota_);
  swap(_impl_.collsiontriggered_, other->_impl_.collsiontriggered_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmCollisionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[18]);
}

// ===================================================================

class EgmRAPIDdata::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmRAPIDdata>()._impl_._has_bits_);
  static void set_has_digval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EgmRAPIDdata::EgmRAPIDdata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmRAPIDdata)
}
EgmRAPIDdata::EgmRAPIDdata(const EgmRAPIDdata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmRAPIDdata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dnum_){from._impl_.dnum_}
    , decltype(_impl_.digval_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.digval_ = from._impl_.digval_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRAPIDdata)
}

inline void EgmRAPIDdata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dnum_){arena}
    , decltype(_impl_.digval_){false}
  };
}

EgmRAPIDdata::~EgmRAPIDdata() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRAPIDdata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmRAPIDdata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dnum_.~RepeatedField();
}

void EgmRAPIDdata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmRAPIDdata::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRAPIDdata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dnum_.Clear();
  _impl_.digval_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmRAPIDdata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool digVal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_digval(&has_bits);
          _impl_.digval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double dnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dnum(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_dnum(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmRAPIDdata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRAPIDdata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool digVal = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_digval(), target);
  }

  // repeated double dnum = 2;
  for (int i = 0, n = this->_internal_dnum_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_dnum(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRAPIDdata)
  return target;
}

size_t EgmRAPIDdata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRAPIDdata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double dnum = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_dnum_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dnum_size());
    total_size += data_size;
  }

  // optional bool digVal = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmRAPIDdata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmRAPIDdata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmRAPIDdata::GetClassData() const { return &_class_data_; }


void EgmRAPIDdata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmRAPIDdata*>(&to_msg);
  auto& from = static_cast<const EgmRAPIDdata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRAPIDdata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dnum_.MergeFrom(from._impl_.dnum_);
  if (from._internal_has_digval()) {
    _this->_internal_set_digval(from._internal_digval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmRAPIDdata::CopyFrom(const EgmRAPIDdata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRAPIDdata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRAPIDdata::IsInitialized() const {
  return true;
}

void EgmRAPIDdata::InternalSwap(EgmRAPIDdata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dnum_.InternalSwap(&other->_impl_.dnum_);
  swap(_impl_.digval_, other->_impl_.digval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmRAPIDdata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[19]);
}

// ===================================================================

class EgmRobot::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmRobot>()._impl_._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmRobot* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmFeedBack& feedback(const EgmRobot* msg);
  static void set_has_feedback(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmPlanned& planned(const EgmRobot* msg);
  static void set_has_planned(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmMotorState& motorstate(const EgmRobot* msg);
  static void set_has_motorstate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::abb::egm::EgmMCIState& mcistate(const EgmRobot* msg);
  static void set_has_mcistate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mciconvergencemet(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::abb::egm::EgmTestSignals& testsignals(const EgmRobot* msg);
  static void set_has_testsignals(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate(const EgmRobot* msg);
  static void set_has_rapidexecstate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::abb::egm::EgmMeasuredForce& measuredforce(const EgmRobot* msg);
  static void set_has_measuredforce(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_utilizationrate(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_moveindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::abb::egm::EgmCollisionInfo& collisioninfo(const EgmRobot* msg);
  static void set_has_collisioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::abb::egm::EgmRAPIDdata& rapidfromrobot(const EgmRobot* msg);
  static void set_has_rapidfromrobot(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::abb::egm::EgmHeader&
EgmRobot::_Internal::header(const EgmRobot* msg) {
  return *msg->_impl_.header_;
}
const ::abb::egm::EgmFeedBack&
EgmRobot::_Internal::feedback(const EgmRobot* msg) {
  return *msg->_impl_.feedback_;
}
const ::abb::egm::EgmPlanned&
EgmRobot::_Internal::planned(const EgmRobot* msg) {
  return *msg->_impl_.planned_;
}
const ::abb::egm::EgmMotorState&
EgmRobot::_Internal::motorstate(const EgmRobot* msg) {
  return *msg->_impl_.motorstate_;
}
const ::abb::egm::EgmMCIState&
EgmRobot::_Internal::mcistate(const EgmRobot* msg) {
  return *msg->_impl_.mcistate_;
}
const ::abb::egm::EgmTestSignals&
EgmRobot::_Internal::testsignals(const EgmRobot* msg) {
  return *msg->_impl_.testsignals_;
}
const ::abb::egm::EgmRapidCtrlExecState&
EgmRobot::_Internal::rapidexecstate(const EgmRobot* msg) {
  return *msg->_impl_.rapidexecstate_;
}
const ::abb::egm::EgmMeasuredForce&
EgmRobot::_Internal::measuredforce(const EgmRobot* msg) {
  return *msg->_impl_.measuredforce_;
}
const ::abb::egm::EgmCollisionInfo&
EgmRobot::_Internal::collisioninfo(const EgmRobot* msg) {
  return *msg->_impl_.collisioninfo_;
}
const ::abb::egm::EgmRAPIDdata&
EgmRobot::_Internal::rapidfromrobot(const EgmRobot* msg) {
  return *msg->_impl_.rapidfromrobot_;
}
EgmRobot::EgmRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmRobot)
}
EgmRobot::EgmRobot(const EgmRobot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmRobot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.feedback_){nullptr}
    , decltype(_impl_.planned_){nullptr}
    , decltype(_impl_.motorstate_){nullptr}
    , decltype(_impl_.mcistate_){nullptr}
    , decltype(_impl_.testsignals_){nullptr}
    , decltype(_impl_.rapidexecstate_){nullptr}
    , decltype(_impl_.measuredforce_){nullptr}
    , decltype(_impl_.collisioninfo_){nullptr}
    , decltype(_impl_.rapidfromrobot_){nullptr}
    , decltype(_impl_.mciconvergencemet_){}
    , decltype(_impl_.moveindex_){}
    , decltype(_impl_.utilizationrate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::abb::egm::EgmHeader(*from._impl_.header_);
  }
  if (from._internal_has_feedback()) {
    _this->_impl_.feedback_ = new ::abb::egm::EgmFeedBack(*from._impl_.feedback_);
  }
  if (from._internal_has_planned()) {
    _this->_impl_.planned_ = new ::abb::egm::EgmPlanned(*from._impl_.planned_);
  }
  if (from._internal_has_motorstate()) {
    _this->_impl_.motorstate_ = new ::abb::egm::EgmMotorState(*from._impl_.motorstate_);
  }
  if (from._internal_has_mcistate()) {
    _this->_impl_.mcistate_ = new ::abb::egm::EgmMCIState(*from._impl_.mcistate_);
  }
  if (from._internal_has_testsignals()) {
    _this->_impl_.testsignals_ = new ::abb::egm::EgmTestSignals(*from._impl_.testsignals_);
  }
  if (from._internal_has_rapidexecstate()) {
    _this->_impl_.rapidexecstate_ = new ::abb::egm::EgmRapidCtrlExecState(*from._impl_.rapidexecstate_);
  }
  if (from._internal_has_measuredforce()) {
    _this->_impl_.measuredforce_ = new ::abb::egm::EgmMeasuredForce(*from._impl_.measuredforce_);
  }
  if (from._internal_has_collisioninfo()) {
    _this->_impl_.collisioninfo_ = new ::abb::egm::EgmCollisionInfo(*from._impl_.collisioninfo_);
  }
  if (from._internal_has_rapidfromrobot()) {
    _this->_impl_.rapidfromrobot_ = new ::abb::egm::EgmRAPIDdata(*from._impl_.rapidfromrobot_);
  }
  ::memcpy(&_impl_.mciconvergencemet_, &from._impl_.mciconvergencemet_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.utilizationrate_) -
    reinterpret_cast<char*>(&_impl_.mciconvergencemet_)) + sizeof(_impl_.utilizationrate_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRobot)
}

inline void EgmRobot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.feedback_){nullptr}
    , decltype(_impl_.planned_){nullptr}
    , decltype(_impl_.motorstate_){nullptr}
    , decltype(_impl_.mcistate_){nullptr}
    , decltype(_impl_.testsignals_){nullptr}
    , decltype(_impl_.rapidexecstate_){nullptr}
    , decltype(_impl_.measuredforce_){nullptr}
    , decltype(_impl_.collisioninfo_){nullptr}
    , decltype(_impl_.rapidfromrobot_){nullptr}
    , decltype(_impl_.mciconvergencemet_){false}
    , decltype(_impl_.moveindex_){0u}
    , decltype(_impl_.utilizationrate_){0}
  };
}

EgmRobot::~EgmRobot() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRobot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmRobot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.feedback_;
  if (this != internal_default_instance()) delete _impl_.planned_;
  if (this != internal_default_instance()) delete _impl_.motorstate_;
  if (this != internal_default_instance()) delete _impl_.mcistate_;
  if (this != internal_default_instance()) delete _impl_.testsignals_;
  if (this != internal_default_instance()) delete _impl_.rapidexecstate_;
  if (this != internal_default_instance()) delete _impl_.measuredforce_;
  if (this != internal_default_instance()) delete _impl_.collisioninfo_;
  if (this != internal_default_instance()) delete _impl_.rapidfromrobot_;
}

void EgmRobot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmRobot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRobot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.feedback_ != nullptr);
      _impl_.feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.planned_ != nullptr);
      _impl_.planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.motorstate_ != nullptr);
      _impl_.motorstate_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.mcistate_ != nullptr);
      _impl_.mcistate_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.testsignals_ != nullptr);
      _impl_.testsignals_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.rapidexecstate_ != nullptr);
      _impl_.rapidexecstate_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.measuredforce_ != nullptr);
      _impl_.measuredforce_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.collisioninfo_ != nullptr);
      _impl_.collisioninfo_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.rapidfromrobot_ != nullptr);
      _impl_.rapidfromrobot_->Clear();
    }
  }
  if (cached_has_bits & 0x00001c00u) {
    ::memset(&_impl_.mciconvergencemet_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.utilizationrate_) -
        reinterpret_cast<char*>(&_impl_.mciconvergencemet_)) + sizeof(_impl_.utilizationrate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmRobot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmFeedBack feedBack = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_feedback(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPlanned planned = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_planned(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMotorState motorState = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_motorstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMCIState mciState = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mcistate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mciConvergenceMet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mciconvergencemet(&has_bits);
          _impl_.mciconvergencemet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmTestSignals testSignals = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_testsignals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rapidexecstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_measuredforce(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double utilizationRate = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_utilizationrate(&has_bits);
          _impl_.utilizationrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 moveIndex = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_moveindex(&has_bits);
          _impl_.moveindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmCollisionInfo CollisionInfo = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_collisioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmRAPIDdata RAPIDfromRobot = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_rapidfromrobot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmRobot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRobot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::feedback(this),
        _Internal::feedback(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::planned(this),
        _Internal::planned(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::motorstate(this),
        _Internal::motorstate(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::mcistate(this),
        _Internal::mcistate(this).GetCachedSize(), target, stream);
  }

  // optional bool mciConvergenceMet = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_mciconvergencemet(), target);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::testsignals(this),
        _Internal::testsignals(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rapidexecstate(this),
        _Internal::rapidexecstate(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::measuredforce(this),
        _Internal::measuredforce(this).GetCachedSize(), target, stream);
  }

  // optional double utilizationRate = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_utilizationrate(), target);
  }

  // optional uint32 moveIndex = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_moveindex(), target);
  }

  // optional .abb.egm.EgmCollisionInfo CollisionInfo = 12;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::collisioninfo(this),
        _Internal::collisioninfo(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmRAPIDdata RAPIDfromRobot = 13;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::rapidfromrobot(this),
        _Internal::rapidfromrobot(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRobot)
  return target;
}

size_t EgmRobot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRobot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .abb.egm.EgmFeedBack feedBack = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.feedback_);
    }

    // optional .abb.egm.EgmPlanned planned = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.planned_);
    }

    // optional .abb.egm.EgmMotorState motorState = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.motorstate_);
    }

    // optional .abb.egm.EgmMCIState mciState = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mcistate_);
    }

    // optional .abb.egm.EgmTestSignals testSignals = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.testsignals_);
    }

    // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rapidexecstate_);
    }

    // optional .abb.egm.EgmMeasuredForce measuredForce = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.measuredforce_);
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional .abb.egm.EgmCollisionInfo CollisionInfo = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.collisioninfo_);
    }

    // optional .abb.egm.EgmRAPIDdata RAPIDfromRobot = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rapidfromrobot_);
    }

    // optional bool mciConvergenceMet = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional uint32 moveIndex = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_moveindex());
    }

    // optional double utilizationRate = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmRobot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmRobot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmRobot::GetClassData() const { return &_class_data_; }


void EgmRobot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmRobot*>(&to_msg);
  auto& from = static_cast<const EgmRobot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRobot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_feedback()->::abb::egm::EgmFeedBack::MergeFrom(
          from._internal_feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(
          from._internal_planned());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_motorstate()->::abb::egm::EgmMotorState::MergeFrom(
          from._internal_motorstate());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_mcistate()->::abb::egm::EgmMCIState::MergeFrom(
          from._internal_mcistate());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_testsignals()->::abb::egm::EgmTestSignals::MergeFrom(
          from._internal_testsignals());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_rapidexecstate()->::abb::egm::EgmRapidCtrlExecState::MergeFrom(
          from._internal_rapidexecstate());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_measuredforce()->::abb::egm::EgmMeasuredForce::MergeFrom(
          from._internal_measuredforce());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_collisioninfo()->::abb::egm::EgmCollisionInfo::MergeFrom(
          from._internal_collisioninfo());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_rapidfromrobot()->::abb::egm::EgmRAPIDdata::MergeFrom(
          from._internal_rapidfromrobot());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.mciconvergencemet_ = from._impl_.mciconvergencemet_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.moveindex_ = from._impl_.moveindex_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.utilizationrate_ = from._impl_.utilizationrate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmRobot::CopyFrom(const EgmRobot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRobot::IsInitialized() const {
  if (_internal_has_feedback()) {
    if (!_impl_.feedback_->IsInitialized()) return false;
  }
  if (_internal_has_planned()) {
    if (!_impl_.planned_->IsInitialized()) return false;
  }
  if (_internal_has_motorstate()) {
    if (!_impl_.motorstate_->IsInitialized()) return false;
  }
  if (_internal_has_mcistate()) {
    if (!_impl_.mcistate_->IsInitialized()) return false;
  }
  if (_internal_has_rapidexecstate()) {
    if (!_impl_.rapidexecstate_->IsInitialized()) return false;
  }
  return true;
}

void EgmRobot::InternalSwap(EgmRobot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmRobot, _impl_.utilizationrate_)
      + sizeof(EgmRobot::_impl_.utilizationrate_)
      - PROTOBUF_FIELD_OFFSET(EgmRobot, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmRobot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[20]);
}

// ===================================================================

class EgmSensor::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSensor>()._impl_._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmSensor* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPlanned& planned(const EgmSensor* msg);
  static void set_has_planned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::abb::egm::EgmSpeedRef& speedref(const EgmSensor* msg);
  static void set_has_speedref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::abb::egm::EgmRAPIDdata& rapidtorobot(const EgmSensor* msg);
  static void set_has_rapidtorobot(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::abb::egm::EgmHeader&
EgmSensor::_Internal::header(const EgmSensor* msg) {
  return *msg->_impl_.header_;
}
const ::abb::egm::EgmPlanned&
EgmSensor::_Internal::planned(const EgmSensor* msg) {
  return *msg->_impl_.planned_;
}
const ::abb::egm::EgmSpeedRef&
EgmSensor::_Internal::speedref(const EgmSensor* msg) {
  return *msg->_impl_.speedref_;
}
const ::abb::egm::EgmRAPIDdata&
EgmSensor::_Internal::rapidtorobot(const EgmSensor* msg) {
  return *msg->_impl_.rapidtorobot_;
}
EgmSensor::EgmSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSensor)
}
EgmSensor::EgmSensor(const EgmSensor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmSensor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.planned_){nullptr}
    , decltype(_impl_.speedref_){nullptr}
    , decltype(_impl_.rapidtorobot_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::abb::egm::EgmHeader(*from._impl_.header_);
  }
  if (from._internal_has_planned()) {
    _this->_impl_.planned_ = new ::abb::egm::EgmPlanned(*from._impl_.planned_);
  }
  if (from._internal_has_speedref()) {
    _this->_impl_.speedref_ = new ::abb::egm::EgmSpeedRef(*from._impl_.speedref_);
  }
  if (from._internal_has_rapidtorobot()) {
    _this->_impl_.rapidtorobot_ = new ::abb::egm::EgmRAPIDdata(*from._impl_.rapidtorobot_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensor)
}

inline void EgmSensor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.planned_){nullptr}
    , decltype(_impl_.speedref_){nullptr}
    , decltype(_impl_.rapidtorobot_){nullptr}
  };
}

EgmSensor::~EgmSensor() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmSensor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.planned_;
  if (this != internal_default_instance()) delete _impl_.speedref_;
  if (this != internal_default_instance()) delete _impl_.rapidtorobot_;
}

void EgmSensor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.planned_ != nullptr);
      _impl_.planned_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.speedref_ != nullptr);
      _impl_.speedref_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rapidtorobot_ != nullptr);
      _impl_.rapidtorobot_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSensor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPlanned planned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_planned(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmSpeedRef speedRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_speedref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmRAPIDdata RAPIDtoRobot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rapidtorobot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmSensor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::planned(this),
        _Internal::planned(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::speedref(this),
        _Internal::speedref(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmRAPIDdata RAPIDtoRobot = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rapidtorobot(this),
        _Internal::rapidtorobot(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensor)
  return target;
}

size_t EgmSensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .abb.egm.EgmPlanned planned = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.planned_);
    }

    // optional .abb.egm.EgmSpeedRef speedRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.speedref_);
    }

    // optional .abb.egm.EgmRAPIDdata RAPIDtoRobot = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rapidtorobot_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmSensor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmSensor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmSensor::GetClassData() const { return &_class_data_; }


void EgmSensor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmSensor*>(&to_msg);
  auto& from = static_cast<const EgmSensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(
          from._internal_planned());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_speedref()->::abb::egm::EgmSpeedRef::MergeFrom(
          from._internal_speedref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rapidtorobot()->::abb::egm::EgmRAPIDdata::MergeFrom(
          from._internal_rapidtorobot());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmSensor::CopyFrom(const EgmSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensor::IsInitialized() const {
  if (_internal_has_planned()) {
    if (!_impl_.planned_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensor::InternalSwap(EgmSensor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSensor, _impl_.rapidtorobot_)
      + sizeof(EgmSensor::_impl_.rapidtorobot_)
      - PROTOBUF_FIELD_OFFSET(EgmSensor, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSensor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[21]);
}

// ===================================================================

class EgmSensorPathCorr::_Internal {
 public:
  using HasBits = decltype(std::declval<EgmSensorPathCorr>()._impl_._has_bits_);
  static const ::abb::egm::EgmHeader& header(const EgmSensorPathCorr* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::abb::egm::EgmPathCorr& pathcorr(const EgmSensorPathCorr* msg);
  static void set_has_pathcorr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::abb::egm::EgmHeader&
EgmSensorPathCorr::_Internal::header(const EgmSensorPathCorr* msg) {
  return *msg->_impl_.header_;
}
const ::abb::egm::EgmPathCorr&
EgmSensorPathCorr::_Internal::pathcorr(const EgmSensorPathCorr* msg) {
  return *msg->_impl_.pathcorr_;
}
EgmSensorPathCorr::EgmSensorPathCorr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:abb.egm.EgmSensorPathCorr)
}
EgmSensorPathCorr::EgmSensorPathCorr(const EgmSensorPathCorr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EgmSensorPathCorr* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pathcorr_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::abb::egm::EgmHeader(*from._impl_.header_);
  }
  if (from._internal_has_pathcorr()) {
    _this->_impl_.pathcorr_ = new ::abb::egm::EgmPathCorr(*from._impl_.pathcorr_);
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensorPathCorr)
}

inline void EgmSensorPathCorr::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.pathcorr_){nullptr}
  };
}

EgmSensorPathCorr::~EgmSensorPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensorPathCorr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EgmSensorPathCorr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.pathcorr_;
}

void EgmSensorPathCorr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EgmSensorPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensorPathCorr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pathcorr_ != nullptr);
      _impl_.pathcorr_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EgmSensorPathCorr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .abb.egm.EgmPathCorr pathCorr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathcorr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EgmSensorPathCorr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensorPathCorr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pathcorr(this),
        _Internal::pathcorr(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensorPathCorr)
  return target;
}

size_t EgmSensorPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensorPathCorr)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

    // optional .abb.egm.EgmPathCorr pathCorr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pathcorr_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EgmSensorPathCorr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EgmSensorPathCorr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EgmSensorPathCorr::GetClassData() const { return &_class_data_; }


void EgmSensorPathCorr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EgmSensorPathCorr*>(&to_msg);
  auto& from = static_cast<const EgmSensorPathCorr&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensorPathCorr)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header()->::abb::egm::EgmHeader::MergeFrom(
          from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pathcorr()->::abb::egm::EgmPathCorr::MergeFrom(
          from._internal_pathcorr());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EgmSensorPathCorr::CopyFrom(const EgmSensorPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensorPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensorPathCorr::IsInitialized() const {
  if (_internal_has_pathcorr()) {
    if (!_impl_.pathcorr_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensorPathCorr::InternalSwap(EgmSensorPathCorr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EgmSensorPathCorr, _impl_.pathcorr_)
      + sizeof(EgmSensorPathCorr::_impl_.pathcorr_)
      - PROTOBUF_FIELD_OFFSET(EgmSensorPathCorr, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EgmSensorPathCorr::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_egm_2eproto_getter, &descriptor_table_egm_2eproto_once,
      file_level_metadata_egm_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace egm
}  // namespace abb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::abb::egm::EgmHeader*
Arena::CreateMaybeMessage< ::abb::egm::EgmHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmCartesian*
Arena::CreateMaybeMessage< ::abb::egm::EgmCartesian >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmCartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmQuaternion*
Arena::CreateMaybeMessage< ::abb::egm::EgmQuaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmQuaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmEuler*
Arena::CreateMaybeMessage< ::abb::egm::EgmEuler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmEuler >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmClock*
Arena::CreateMaybeMessage< ::abb::egm::EgmClock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmClock >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPose*
Arena::CreateMaybeMessage< ::abb::egm::EgmPose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPose >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmCartesianSpeed*
Arena::CreateMaybeMessage< ::abb::egm::EgmCartesianSpeed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmCartesianSpeed >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmJoints*
Arena::CreateMaybeMessage< ::abb::egm::EgmJoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmJoints >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmExternalJoints*
Arena::CreateMaybeMessage< ::abb::egm::EgmExternalJoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmExternalJoints >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPlanned*
Arena::CreateMaybeMessage< ::abb::egm::EgmPlanned >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPlanned >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSpeedRef*
Arena::CreateMaybeMessage< ::abb::egm::EgmSpeedRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSpeedRef >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmPathCorr*
Arena::CreateMaybeMessage< ::abb::egm::EgmPathCorr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmPathCorr >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmFeedBack*
Arena::CreateMaybeMessage< ::abb::egm::EgmFeedBack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmFeedBack >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMotorState*
Arena::CreateMaybeMessage< ::abb::egm::EgmMotorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMotorState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMCIState*
Arena::CreateMaybeMessage< ::abb::egm::EgmMCIState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMCIState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmRapidCtrlExecState*
Arena::CreateMaybeMessage< ::abb::egm::EgmRapidCtrlExecState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmRapidCtrlExecState >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmTestSignals*
Arena::CreateMaybeMessage< ::abb::egm::EgmTestSignals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmTestSignals >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmMeasuredForce*
Arena::CreateMaybeMessage< ::abb::egm::EgmMeasuredForce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmMeasuredForce >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmCollisionInfo*
Arena::CreateMaybeMessage< ::abb::egm::EgmCollisionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmCollisionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmRAPIDdata*
Arena::CreateMaybeMessage< ::abb::egm::EgmRAPIDdata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmRAPIDdata >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmRobot*
Arena::CreateMaybeMessage< ::abb::egm::EgmRobot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmRobot >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSensor*
Arena::CreateMaybeMessage< ::abb::egm::EgmSensor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSensor >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::EgmSensorPathCorr*
Arena::CreateMaybeMessage< ::abb::egm::EgmSensorPathCorr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::abb::egm::EgmSensorPathCorr >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
